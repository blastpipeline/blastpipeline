diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index b0058de..d92390f 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -227,9 +227,15 @@
 #include "nsIBrowserSearchService.h"
 #endif
 
+#include "sys/time.h" //blast
+#include "mozilla/Logging.h" //blast
+
 using namespace mozilla;
 using namespace mozilla::dom;
 
+static LazyLogModule mylogger("mylogger"); //blast
+
+
 // Threshold value in ms for META refresh based redirects
 #define REFRESH_REDIRECT_TIMER 15000
 
@@ -668,6 +674,18 @@ nsDocShell::LoadURI(nsIURI* aURI, nsIDocShellLoadInfo* aLoadInfo,
   if (!IsNavigationAllowed(true, false)) {
     return NS_OK;  // JS may not handle returning of an error code
   }
+  
+  //blast
+  if (aURI) {
+  struct timeval tp;
+  gettimeofday(&tp, NULL);
+  double tp_now = tp.tv_sec + tp.tv_usec/1000000.0;
+  nsAutoCString logSpec;
+  aURI->GetSpec(logSpec);
+  MOZ_LOG(mylogger, LogLevel::Debug,
+          ("f=nsDocShell::LoadURI\tt=%f\turi=%s\n", tp_now, logSpec.get())
+         );
+  }
 
   nsCOMPtr<nsIURI> referrer;
   nsCOMPtr<nsIURI> originalURI;
@@ -10173,6 +10191,18 @@ nsresult nsDocShell::DoURILoad(
     // down.
     return NS_OK;
   }
+  
+  //blast
+  if (aURI) {
+  struct timeval tp;
+  gettimeofday(&tp, NULL);
+  double tp_now = tp.tv_sec + tp.tv_usec/1000000.0;
+  nsAutoCString logSpec;
+  aURI->GetSpec(logSpec);
+  MOZ_LOG(mylogger, LogLevel::Debug,
+          ("f=nsDocShell::DoURILoad\tt=%f\turi=%s\n", tp_now, logSpec.get())
+         );
+  }
 
   nsresult rv;
   nsCOMPtr<nsIURILoader> uriLoader =
@@ -13024,6 +13054,19 @@ nsDocShell::OnLinkClick(nsIContent* aContent, nsIURI* aURI,
                         nsIPrincipal* aTriggeringPrincipal) {
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
 
+
+  //blast
+  if (aURI) {
+  struct timeval tp;
+  gettimeofday(&tp, NULL);
+  double tp_now = tp.tv_sec + tp.tv_usec/1000000.0;
+  nsAutoCString logSpec;
+  aURI->GetSpec(logSpec);
+  MOZ_LOG(mylogger, LogLevel::Debug,
+          ("f=nsDocShell::OnLinkClick\tt=%f\turi=%s\n", tp_now, logSpec.get())
+         );
+  }
+
   if (!IsNavigationAllowed() || !IsOKToLoadURI(aURI)) {
     return NS_OK;
   }
@@ -13081,6 +13124,19 @@ nsDocShell::OnLinkClickSync(
     int64_t aPostDataStreamLength, nsIInputStream* aHeadersDataStream,
     bool aNoOpenerImplied, nsIDocShell** aDocShell, nsIRequest** aRequest,
     nsIPrincipal* aTriggeringPrincipal) {
+
+  //blast
+  if (aURI) {
+  struct timeval tp;
+  gettimeofday(&tp, NULL);
+  double tp_now = tp.tv_sec + tp.tv_usec/1000000.0;
+  nsAutoCString logSpec;
+  aURI->GetSpec(logSpec);
+  MOZ_LOG(mylogger, LogLevel::Debug,
+          ("f=nsDocShell::OnLinkClickSync\tt=%f\turi=%s\n", tp_now, logSpec.get())
+         );
+  }
+
   // Initialize the DocShell / Request
   if (aDocShell) {
     *aDocShell = nullptr;
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
index 1be4a5c..e71c32d 100644
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -1765,6 +1765,30 @@ pref("network.http.redirection-limit", 20);
 pref("network.http.accept-encoding", "gzip, deflate");
 pref("network.http.accept-encoding.secure", "gzip, deflate, br");
 
+//repipeline
+
+pref("network.http.pipelining"      , false);
+pref("network.http.pipelining.ssl"  , false); // disable pipelining over SSL
+pref("network.http.pipelining.abtest", false);
+pref("network.http.proxy.pipelining", false);
+pref("network.http.pipelining.policy"      , 1);
+
+// Max number of requests in the pipeline
+pref("network.http.pipelining.maxrequests" , 32);
+
+// An optimistic request is one pipelined when policy might allow a new
+// connection instead
+pref("network.http.pipelining.max-optimistic-requests" , 4);
+
+pref("network.http.pipelining.aggressive", false);
+pref("network.http.pipelining.maxsize" , 300000);
+pref("network.http.pipelining.reschedule-on-timeout", true);
+pref("network.http.pipelining.reschedule-timeout", 1500);
+
+// The read-timeout is a ms timer that causes the transaction to be completely
+// restarted without pipelining.
+pref("network.http.pipelining.read-timeout", 30000);
+
 // Prompt for redirects resulting in unsafe HTTP requests
 pref("network.http.prompt-temp-redirect", false);
 
diff --git a/netwerk/base/nsIRequest.idl b/netwerk/base/nsIRequest.idl
index be625a5..6be8450 100644
--- a/netwerk/base/nsIRequest.idl
+++ b/netwerk/base/nsIRequest.idl
@@ -142,6 +142,13 @@ interface nsIRequest : nsISupports
      */
 
     /**
+     *  This flag prevents loading of the request with an HTTP pipeline.
+     *  Generally this is because the resource is expected to take a
+     *  while to load and may cause head of line blocking problems.
+     */
+    const unsigned long INHIBIT_PIPELINE = 1 << 6;
+
+    /**
      * This flag prevents caching of any kind.  It does not, however, prevent
      * cached content from being used to satisfy this request.
      */
diff --git a/netwerk/base/nsSocketTransport2.cpp b/netwerk/base/nsSocketTransport2.cpp
index 3f16449..b00b87f 100644
--- a/netwerk/base/nsSocketTransport2.cpp
+++ b/netwerk/base/nsSocketTransport2.cpp
@@ -70,6 +70,8 @@ static NS_DEFINE_CID(kDNSServiceCID, NS_DNSSERVICE_CID);
 namespace mozilla {
 namespace net {
 
+static LazyLogModule mylogger("httplogger"); //remember this has to be here (under namespace mozilla)
+
 class nsSocketEvent : public Runnable {
  public:
   nsSocketEvent(nsSocketTransport *transport, uint32_t type,
@@ -1452,6 +1454,7 @@ nsresult nsSocketTransport::InitiateSocket() {
 
   bool connectCalled = true;  // This is only needed for telemetry.
   status = PR_Connect(fd, &prAddr, NS_SOCKET_CONNECT_TIMEOUT);
+
   PRErrorCode code = PR_GetError();
   if ((status == PR_SUCCESS) && tfo) {
     {
@@ -1524,11 +1527,11 @@ nsresult nsSocketTransport::InitiateSocket() {
         Telemetry::PRCONNECT_BLOCKING_TIME_LINK_CHANGE,
         Telemetry::PRCONNECT_BLOCKING_TIME_OFFLINE);
   }
-
   if (status == PR_SUCCESS) {
-    //
-    // we are connected!
-    //
+  //
+  // we are connected!
+  //
+
     OnSocketConnected();
   } else {
 #if defined(TEST_CONNECT_ERRORS)
@@ -1798,11 +1801,18 @@ void nsSocketTransport::OnMsgOutputClosed(nsresult reason) {
 }
 
 void nsSocketTransport::OnSocketConnected() {
+
+  MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsSocketTransport::OnSocketConnected\n"));
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
   SOCKET_LOG(("  advancing to STATE_TRANSFERRING\n"));
 
   mPollFlags = (PR_POLL_READ | PR_POLL_WRITE | PR_POLL_EXCEPT);
   mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
+
+
+  //repipeline:
+  /*if (mState == STATE_CONNECTING) mState = STATE_SENDINGGET;
+  if (mState == STATE_SENTGET) mState = STATE_TRANSFERRING;*/
   mState = STATE_TRANSFERRING;
 
   // Set the m*AddrIsSet flags only when state has reached TRANSFERRING
@@ -2054,6 +2064,8 @@ void nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16_t outFlags) {
   SOCKET_LOG(("nsSocketTransport::OnSocketReady [this=%p outFlags=%hd]\n", this,
               outFlags));
 
+  MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsSocketTransport::OnSocketReady\tstate=%d\n", mState));
+
   if (outFlags == -1) {
     SOCKET_LOG(("socket timeout expired\n"));
     mCondition = NS_ERROR_NET_TIMEOUT;
@@ -2094,7 +2106,21 @@ void nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16_t outFlags) {
     }
     // Update poll timeout in case it was changed
     mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
-  } else if ((mState == STATE_CONNECTING) && !gIOService->IsNetTearingDown()) {
+  }
+  //repipeline optdata
+  /*else if (mState == STATE_SENDINGGET) {
+      MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsSocketTransport::OnSocketReady poke\tstate=%d\n", mState));
+      if ((mPollFlags & PR_POLL_WRITE) && (outFlags & ~PR_POLL_READ)) {
+          mOutput.OnSocketReady(NS_OK);
+      }
+      mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
+      mPollFlags = (PR_POLL_EXCEPT | PR_POLL_READ | PR_POLL_WRITE);
+      //mState = STATE_TRANSFERRING;
+      mState = STATE_SENTGET;
+  }*/
+  //repipeline: Adds "or mState == STATE_SENTGET"
+  else if ((mState == STATE_CONNECTING || mState == STATE_SENTGET) && !gIOService->IsNetTearingDown()) {
+  ///else if ((mState == STATE_CONNECTING) && !gIOService->IsNetTearingDown()) {
     // We do not need to do PR_ConnectContinue when we are already
     // shutting down.
 
@@ -2137,6 +2163,17 @@ void nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16_t outFlags) {
           Telemetry::PRCONNECTCONTINUE_BLOCKING_TIME_OFFLINE);
     }
 
+//repipeline: fake a success
+
+    /*bool isUsingSocks = mProxyTransparent && !mProxyHost.IsEmpty();
+    if (status == PR_SUCCESS && mState == STATE_CONNECTING) {
+        OnSocketConnected();
+        //if (isUsingSocks) {
+        mState = STATE_SENDINGGET;
+        //}
+    }
+    else if (status == PR_SUCCESS && mState == STATE_SENTGET) {*/
+
     if (status == PR_SUCCESS) {
       //
       // we are connected!
@@ -2160,11 +2197,14 @@ void nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16_t outFlags) {
       //
       // If the connect is still not ready, then continue polling...
       //
+      MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnSocketReady PR_ConnectContinue fail\terror=%d\tBLOCK=%d\tPROGRESS=%d", code, PR_WOULD_BLOCK_ERROR, PR_IN_PROGRESS_ERROR));
       if ((PR_WOULD_BLOCK_ERROR == code) || (PR_IN_PROGRESS_ERROR == code)) {
-        // Set up the select flags for connect...
-        mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
-        // Update poll timeout in case it was changed
-        mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
+        //if (mState != STATE_SENTGET) {
+            // Set up the select flags for connect...
+            mPollFlags = (PR_POLL_EXCEPT | PR_POLL_WRITE);
+            // Update poll timeout in case it was changed
+            mPollTimeout = mTimeouts[TIMEOUT_CONNECT];
+        //}
       }
       //
       // The SOCKS proxy rejected our request. Find out why.
diff --git a/netwerk/base/nsSocketTransport2.h b/netwerk/base/nsSocketTransport2.h
index 27044c2..910620a 100644
--- a/netwerk/base/nsSocketTransport2.h
+++ b/netwerk/base/nsSocketTransport2.h
@@ -189,6 +189,8 @@ class nsSocketTransport final : public nsASocketHandler,
     STATE_RESOLVING,
     STATE_CONNECTING,
     STATE_TRANSFERRING
+    , STATE_SENDINGGET
+    , STATE_SENTGET //repipeline
   };
 
   // Safer way to get and automatically release PRFileDesc objects.
diff --git a/netwerk/base/nsSocketTransportService2.cpp b/netwerk/base/nsSocketTransportService2.cpp
index 7dff0fc..4e85c7d 100644
--- a/netwerk/base/nsSocketTransportService2.cpp
+++ b/netwerk/base/nsSocketTransportService2.cpp
@@ -1019,8 +1019,9 @@ nsresult nsSocketTransportService::DoPollIteration(TimeDuration *pollDuration) {
       DetachSocket(mActiveList, &mActiveList[i]);
     else {
       uint16_t in_flags = mActiveList[i].mHandler->mPollFlags;
-      if (in_flags == 0)
+      if (in_flags == 0) {
         MoveToIdleList(&mActiveList[i]);
+      }
       else {
         // update poll flags
         mPollList[i + 1].in_flags = in_flags;
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
index 3859a2a..924eb4a 100644
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -174,6 +174,7 @@ struct HttpChannelOpenArgs
   int16_t                     priority;
   uint32_t                    classOfService;
   uint8_t                     redirectionLimit;
+  bool                        allowPipelining;
   bool                        allowSTS;
   uint32_t                    thirdPartyFlags;
   bool                        resumeAt;
diff --git a/netwerk/protocol/http/Http2Push.cpp b/netwerk/protocol/http/Http2Push.cpp
index 937cda9..4113829 100644
--- a/netwerk/protocol/http/Http2Push.cpp
+++ b/netwerk/protocol/http/Http2Push.cpp
@@ -395,6 +395,30 @@ void Http2PushTransactionBuffer::Close(nsresult reason) {
   mIsDone = true;
 }
 
+nsresult
+Http2PushTransactionBuffer::AddTransaction(nsAHttpTransaction *trans)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+uint32_t
+Http2PushTransactionBuffer::PipelineDepth()
+{
+  return 0;
+}
+
+nsresult
+Http2PushTransactionBuffer::SetPipelinePosition(int32_t position)
+{
+  return NS_OK;
+}
+
+int32_t
+Http2PushTransactionBuffer::PipelinePosition()
+{
+  return 1;
+}
+
 nsresult Http2PushTransactionBuffer::GetBufferedData(char *buf, uint32_t count,
                                                      uint32_t *countWritten) {
   *countWritten = std::min(count, static_cast<uint32_t>(Available()));
diff --git a/netwerk/protocol/http/Http2Push.h b/netwerk/protocol/http/Http2Push.h
index c8d4c7c..125a31e 100644
--- a/netwerk/protocol/http/Http2Push.h
+++ b/netwerk/protocol/http/Http2Push.h
@@ -114,7 +114,7 @@ class Http2PushTransactionBuffer final : public nsAHttpTransaction {
 
  private:
   virtual ~Http2PushTransactionBuffer();
-  uint64_t Available();
+  //uint64_t Available(); //repipeline
 
   const static uint32_t kDefaultBufferSize = 4096;
 
diff --git a/netwerk/protocol/http/Http2Session.cpp b/netwerk/protocol/http/Http2Session.cpp
index fcec62e..d48913b 100644
--- a/netwerk/protocol/http/Http2Session.cpp
+++ b/netwerk/protocol/http/Http2Session.cpp
@@ -4284,6 +4284,21 @@ already_AddRefed<nsHttpConnection> Http2Session::TakeHttpConnection() {
   return nullptr;
 }
 
+//repipeline: http2 != pipeline
+uint32_t
+Http2Session::CancelPipeline(nsresult reason)
+{
+  return 0;
+}
+
+nsAHttpTransaction::Classifier
+Http2Session::Classification()
+{
+  if (!mConnection)
+    return nsAHttpTransaction::CLASS_GENERAL;
+  return mConnection->Classification();
+}
+
 already_AddRefed<nsHttpConnection> Http2Session::HttpConnection() {
   if (mConnection) {
     return mConnection->HttpConnection();
@@ -4327,6 +4342,13 @@ void Http2Session::SetDNSWasRefreshed() {
   MOZ_ASSERT(false, "Http2Session::SetDNSWasRefreshed()");
 }
 
+uint64_t
+Http2Session::Available()
+{
+  MOZ_ASSERT(false, "Http2Session::Available()");
+  return 0;
+}
+
 nsHttpRequestHead *Http2Session::RequestHead() {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
   MOZ_ASSERT(false,
@@ -4358,6 +4380,28 @@ nsresult Http2Session::TakeSubTransactions(
   return NS_OK;
 }
 
+//repipeline: Four nsAHttpTransaction functions that need to be ignored
+
+nsresult Http2Session::AddTransaction(nsAHttpTransaction *)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+uint32_t Http2Session::PipelineDepth()
+{
+  return IsDone() ? 0 : 1;
+}
+
+nsresult Http2Session::SetPipelinePosition(int32_t position)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+int32_t Http2Session::PipelinePosition()
+{
+  return 0;
+}
+
 //-----------------------------------------------------------------------------
 // Pass through methods of nsAHttpConnection
 //-----------------------------------------------------------------------------
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
index f0facd9..e5616c7 100644
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -161,6 +161,7 @@ HttpBaseChannel::HttpBaseChannel()
       mWasOpened(false),
       mRequestObserversCalled(false),
       mResponseHeadersModified(false),
+      mAllowPipelining(true),
       mAllowSTS(true),
       mThirdPartyFlags(0),
       mUploadStreamHasHeaders(false),
@@ -1946,16 +1947,19 @@ HttpBaseChannel::VisitOriginalResponseHeaders(nsIHttpHeaderVisitor* aVisitor) {
 }
 
 NS_IMETHODIMP
-HttpBaseChannel::GetAllowPipelining(bool* value) {
+HttpBaseChannel::GetAllowPipelining(bool *value)
+{
   NS_ENSURE_ARG_POINTER(value);
-  *value = false;
+  *value = mAllowPipelining;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-HttpBaseChannel::SetAllowPipelining(bool value) {
+HttpBaseChannel::SetAllowPipelining(bool value)
+{
   ENSURE_CALLED_BEFORE_CONNECT();
-  // nop
+
+  mAllowPipelining = value;
   return NS_OK;
 }
 
@@ -3359,6 +3363,8 @@ nsresult HttpBaseChannel::SetupReplacementChannel(nsIURI* newURI,
     rv = httpChannel->SetReferrerWithPolicy(mReferrer, mReferrerPolicy);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
+  // convey the mAllowPipelining and mAllowSTS flags
+  httpChannel->SetAllowPipelining(mAllowPipelining);
   // convey the mAllowSTS flags
   rv = httpChannel->SetAllowSTS(mAllowSTS);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
diff --git a/netwerk/protocol/http/HttpBaseChannel.h b/netwerk/protocol/http/HttpBaseChannel.h
index d1278ae0..55f58d9 100644
--- a/netwerk/protocol/http/HttpBaseChannel.h
+++ b/netwerk/protocol/http/HttpBaseChannel.h
@@ -566,6 +566,7 @@ class HttpBaseChannel : public nsHashPropertyBag,
   // if 1 all "http-on-{opening|modify|etc}-request" observers have been called
   uint32_t mRequestObserversCalled : 1;
   uint32_t mResponseHeadersModified : 1;
+  uint32_t mAllowPipelining : 1;
   uint32_t mAllowSTS : 1;
   uint32_t mThirdPartyFlags : 3;
   uint32_t mUploadStreamHasHeaders : 1;
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
index 20fedd5..5e54220 100644
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -2514,6 +2514,7 @@ nsresult HttpChannelChild::ContinueAsyncOpen() {
   openArgs.priority() = mPriority;
   openArgs.classOfService() = mClassOfService;
   openArgs.redirectionLimit() = mRedirectionLimit;
+  openArgs.allowPipelining() = mAllowPipelining;
   openArgs.allowSTS() = mAllowSTS;
   openArgs.thirdPartyFlags() = mThirdPartyFlags;
   openArgs.resumeAt() = mSendResumeAt;
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
index 976ccc9..d5e20b2 100644
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -128,7 +128,7 @@ bool HttpChannelParent::Init(const HttpChannelCreationArgs& aArgs) {
           a.apiRedirectTo(), a.topWindowURI(), a.loadFlags(),
           a.requestHeaders(), a.requestMethod(), a.uploadStream(),
           a.uploadStreamHasHeaders(), a.priority(), a.classOfService(),
-          a.redirectionLimit(), a.allowSTS(), a.thirdPartyFlags(), a.resumeAt(),
+          a.redirectionLimit(), a.allowPipelining(), a.allowSTS(), a.thirdPartyFlags(), a.resumeAt(),
           a.startPos(), a.entityID(), a.chooseApplicationCache(),
           a.appCacheClientID(), a.allowSpdy(), a.allowAltSvc(),
           a.beConservative(), a.tlsFlags(), a.loadInfo(),
@@ -420,7 +420,7 @@ bool HttpChannelParent::DoAsyncOpen(
     const RequestHeaderTuples& requestHeaders, const nsCString& requestMethod,
     const OptionalIPCStream& uploadStream, const bool& uploadStreamHasHeaders,
     const int16_t& priority, const uint32_t& classOfService,
-    const uint8_t& redirectionLimit, const bool& allowSTS,
+    const uint8_t& redirectionLimit, const bool& allowPipelining, const bool& allowSTS,
     const uint32_t& thirdPartyFlags, const bool& doResumeAt,
     const uint64_t& startPos, const nsCString& entityID,
     const bool& chooseApplicationCache, const nsCString& appCacheClientID,
@@ -669,6 +669,7 @@ bool HttpChannelParent::DoAsyncOpen(
     httpChannel->SetClassFlags(classOfService);
   }
   httpChannel->SetRedirectionLimit(redirectionLimit);
+  httpChannel->SetAllowPipelining(allowPipelining);
   httpChannel->SetAllowSTS(allowSTS);
   httpChannel->SetThirdPartyFlags(thirdPartyFlags);
   httpChannel->SetAllowSpdy(allowSpdy);
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
index 2a08833..b25158a 100644
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -138,7 +138,7 @@ class HttpChannelParent final : public nsIInterfaceRequestor,
       const RequestHeaderTuples& requestHeaders, const nsCString& requestMethod,
       const OptionalIPCStream& uploadStream, const bool& uploadStreamHasHeaders,
       const int16_t& priority, const uint32_t& classOfService,
-      const uint8_t& redirectionLimit, const bool& allowSTS,
+      const uint8_t& redirectionLimit, const bool& allowPipelining, const bool& allowSTS,
       const uint32_t& thirdPartyFlags, const bool& doResumeAt,
       const uint64_t& startPos, const nsCString& entityID,
       const bool& chooseApplicationCache, const nsCString& appCacheClientID,
diff --git a/netwerk/protocol/http/NullHttpTransaction.cpp b/netwerk/protocol/http/NullHttpTransaction.cpp
index 81ed93d..fe08568 100644
--- a/netwerk/protocol/http/NullHttpTransaction.cpp
+++ b/netwerk/protocol/http/NullHttpTransaction.cpp
@@ -282,5 +282,37 @@ nsHttpConnectionInfo *NullHttpTransaction::ConnectionInfo() {
   return mConnectionInfo;
 }
 
+//repipeline
+
+uint64_t
+NullHttpTransaction::Available()
+{
+  return 0;
+}
+
+nsresult
+NullHttpTransaction::AddTransaction(nsAHttpTransaction *trans)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+uint32_t
+NullHttpTransaction::PipelineDepth()
+{
+  return 0;
+}
+
+nsresult
+NullHttpTransaction::SetPipelinePosition(int32_t position)
+{
+    return NS_OK;
+}
+
+int32_t
+NullHttpTransaction::PipelinePosition()
+{
+  return 1;
+}
+
 }  // namespace net
 }  // namespace mozilla
diff --git a/netwerk/protocol/http/TunnelUtils.cpp b/netwerk/protocol/http/TunnelUtils.cpp
index c2dc069..071377f 100644
--- a/netwerk/protocol/http/TunnelUtils.cpp
+++ b/netwerk/protocol/http/TunnelUtils.cpp
@@ -584,6 +584,16 @@ void TLSFilterTransaction::SetDNSWasRefreshed() {
   mTransaction->SetDNSWasRefreshed();
 }
 
+uint64_t
+TLSFilterTransaction::Available()
+{
+  if (!mTransaction) {
+    return 0;
+  }
+
+  return mTransaction->Available();
+}
+
 void TLSFilterTransaction::SetProxyConnectFailed() {
   if (!mTransaction) {
     return;
@@ -640,6 +650,57 @@ nsresult TLSFilterTransaction::SetProxiedTransaction(
   }
 
   return NS_OK;
+}// AddTransaction is for adding pipelined subtransactions
+nsresult
+TLSFilterTransaction::AddTransaction(nsAHttpTransaction *aTrans)
+{
+  LOG(("TLSFilterTransaction::AddTransaction passing on subtransaction "
+       "[this=%p] aTrans=%p ,mTransaction=%p\n", this, aTrans, mTransaction.get()));
+
+  if (!mTransaction) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return mTransaction->AddTransaction(aTrans);
+}
+
+uint32_t
+TLSFilterTransaction::PipelineDepth()
+{
+  if (!mTransaction) {
+    return 0;
+  }
+
+  return mTransaction->PipelineDepth();
+}
+
+nsresult
+TLSFilterTransaction::SetPipelinePosition(int32_t aPosition)
+{
+  if (!mTransaction) {
+    return NS_OK;
+  }
+
+  return mTransaction->SetPipelinePosition(aPosition);
+}
+
+int32_t
+TLSFilterTransaction::PipelinePosition()
+{
+  if (!mTransaction) {
+    return 1;
+  }
+
+  return mTransaction->PipelinePosition();
+}
+
+nsHttpPipeline *
+TLSFilterTransaction::QueryPipeline()
+{
+  if (!mTransaction) {
+    return nullptr;
+  }
+  return mTransaction->QueryPipeline();
 }
 
 bool TLSFilterTransaction::IsNullTransaction() {
diff --git a/netwerk/protocol/http/TunnelUtils.h b/netwerk/protocol/http/TunnelUtils.h
index f496f7c..847a2ee 100644
--- a/netwerk/protocol/http/TunnelUtils.h
+++ b/netwerk/protocol/http/TunnelUtils.h
@@ -138,6 +138,7 @@ class TLSFilterTransaction final : public nsAHttpTransaction,
                    nsIAsyncOutputStream **outSocketOut);
 
   // nsAHttpTransaction overloads
+  nsHttpPipeline *QueryPipeline() override;
   bool IsNullTransaction() override;
   NullHttpTransaction *QueryNullTransaction() override;
   nsHttpTransaction *QueryHttpTransaction() override;
diff --git a/netwerk/protocol/http/moz.build b/netwerk/protocol/http/moz.build
index cb1190c..6baeb17 100644
--- a/netwerk/protocol/http/moz.build
+++ b/netwerk/protocol/http/moz.build
@@ -91,6 +91,7 @@ UNIFIED_SOURCES += [
     'nsHttpDigestAuth.cpp',
     'nsHttpHeaderArray.cpp',
     'nsHttpNTLMAuth.cpp',
+    'nsHttpPipeline.cpp',
     'nsHttpRequestHead.cpp',
     'nsHttpResponseHead.cpp',
     'nsHttpTransaction.cpp',
diff --git a/netwerk/protocol/http/nsAHttpConnection.h b/netwerk/protocol/http/nsAHttpConnection.h
index f8b8803..b76e6c0 100644
--- a/netwerk/protocol/http/nsAHttpConnection.h
+++ b/netwerk/protocol/http/nsAHttpConnection.h
@@ -136,6 +136,14 @@ class nsAHttpConnection : public nsISupports {
   //  references or ownership.
   virtual nsISocketTransport *Transport() = 0;
 
+  // Cancel and reschedule transactions deeper than the current response.
+  // Returns the number of canceled transactions.
+  virtual uint32_t CancelPipeline(nsresult originalReason) = 0;
+
+  // Read and write class of transaction that is carried on this connection
+  virtual nsAHttpTransaction::Classifier Classification() = 0;
+  virtual void Classify(nsAHttpTransaction::Classifier newclass) = 0;
+
   // The number of transaction bytes written out on this HTTP Connection, does
   // not count CONNECT tunnel setup
   virtual int64_t BytesWritten() = 0;
@@ -166,6 +174,8 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpConnection, NS_AHTTPCONNECTION_IID)
   void DontReuse() override;                                                  \
   MOZ_MUST_USE nsresult PushBack(const char *, uint32_t) override;            \
   already_AddRefed<nsHttpConnection> TakeHttpConnection() override;           \
+  uint32_t CancelPipeline(nsresult originalReason) override; \
+  nsAHttpTransaction::Classifier Classification() override; \
   already_AddRefed<nsHttpConnection> HttpConnection() override;               \
   void TopLevelOuterContentWindowIdChanged(uint64_t windowId) override;       \
   /*                                                                          \
@@ -219,6 +229,12 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpConnection, NS_AHTTPCONNECTION_IID)
   void SetLastTransactionExpectedNoContent(bool val) override {               \
     if (fwdObject) (fwdObject)->SetLastTransactionExpectedNoContent(val);     \
   }                                                                           \
+    void Classify(nsAHttpTransaction::Classifier newclass)  \
+      override                                              \
+    {                                                       \
+    if (fwdObject)                                          \
+        (fwdObject)->Classify(newclass);                    \
+    }                                                       \
   int64_t BytesWritten() override {                                           \
     return fwdObject ? (fwdObject)->BytesWritten() : 0;                       \
   }                                                                           \
diff --git a/netwerk/protocol/http/nsAHttpTransaction.h b/netwerk/protocol/http/nsAHttpTransaction.h
index 3ea8657..c5cbd84 100644
--- a/netwerk/protocol/http/nsAHttpTransaction.h
+++ b/netwerk/protocol/http/nsAHttpTransaction.h
@@ -20,6 +20,7 @@ class nsAHttpConnection;
 class nsAHttpSegmentReader;
 class nsAHttpSegmentWriter;
 class nsHttpTransaction;
+class nsHttpPipeline;
 class nsHttpRequestHead;
 class nsHttpConnectionInfo;
 class NullHttpTransaction;
@@ -73,6 +74,9 @@ class nsAHttpTransaction : public nsSupportsWeakReference {
   // called to notify that a requested DNS cache entry was refreshed.
   virtual void SetDNSWasRefreshed() = 0;
 
+    // called to find out how much request data is available for writing.
+    virtual uint64_t Available() = 0;
+
   // called to read request data from the transaction.
   virtual MOZ_MUST_USE nsresult ReadSegments(nsAHttpSegmentReader *reader,
                                              uint32_t count,
@@ -126,12 +130,31 @@ class nsAHttpTransaction : public nsSupportsWeakReference {
   virtual MOZ_MUST_USE nsresult TakeSubTransactions(
       nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions) = 0;
 
-  // Occasionally the abstract interface has to give way to base implementations
-  // to respect differences between spdy, h2, etc..
-  // These Query* (and IsNullTransaction()) functions provide a way to do
-  // that without using xpcom or rtti. Any calling code that can't deal with
-  // a null response from one of them probably shouldn't be using
-  // nsAHttpTransaction
+    // called to add a sub-transaction in the case of pipelined transactions
+    // classes that do not implement sub transactions
+    // return NS_ERROR_NOT_IMPLEMENTED
+    virtual nsresult AddTransaction(nsAHttpTransaction *transaction) = 0;
+
+    // The total length of the outstanding pipeline comprised of transacations
+    // and sub-transactions.
+    virtual uint32_t PipelineDepth() = 0;
+
+    // Used to inform the connection that it is being used in a pipelined
+    // context. That may influence the handling of some errors.
+    // The value is the pipeline position (> 1).
+    virtual nsresult SetPipelinePosition(int32_t) = 0;
+    virtual int32_t  PipelinePosition() = 0;
+
+    // Occasionally the abstract interface has to give way to base implementations
+    // to respect differences between spdy, pipelines, etc..
+    // These Query* (and IsNullTransaction()) functions provide a way to do
+    // that without using xpcom or rtti. Any calling code that can't deal with
+    // a null response from one of them probably shouldn't be using nsAHttpTransaction
+
+    // If we used rtti this would be the result of doing
+    // dynamic_cast<nsHttpPipeline *>(this).. i.e. it can be nullptr for
+    // non pipeline implementations of nsAHttpTransaction
+    virtual nsHttpPipeline *QueryPipeline() { return nullptr; }
 
   // equivalent to !!dynamic_cast<NullHttpTransaction *>(this)
   // A null transaction is expected to return BASE_STREAM_CLOSED on all of
@@ -161,6 +184,12 @@ class nsAHttpTransaction : public nsSupportsWeakReference {
   virtual bool ResponseTimeoutEnabled() const;
   virtual PRIntervalTime ResponseTimeout();
 
+  //repipeline: only CLASS_SOLO (no pipelining allowed) and CLASS_GENERAL (pipelining allowed) should exist. 
+    enum Classifier  {
+	CLASS_SOLO, 
+        CLASS_GENERAL
+    };
+
   // conceptually the security info is part of the connection, but sometimes
   // in the case of TLS tunneled within TLS the transaction might present
   // a more specific security info that cannot be represented as a layer in
@@ -219,6 +248,7 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpTransaction, NS_AHTTPTRANSACTION_IID)
   nsresult Status() override;                                                  \
   uint32_t Caps() override;                                                    \
   void SetDNSWasRefreshed() override;                                          \
+  uint64_t Available() override; \
   virtual MOZ_MUST_USE nsresult ReadSegments(nsAHttpSegmentReader *, uint32_t, \
                                              uint32_t *) override;             \
   virtual MOZ_MUST_USE nsresult WriteSegments(nsAHttpSegmentWriter *,          \
@@ -229,7 +259,11 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsAHttpTransaction, NS_AHTTPTRANSACTION_IID)
   virtual nsHttpRequestHead *RequestHead() override;                           \
   uint32_t Http1xTransactionCount() override;                                  \
   MOZ_MUST_USE nsresult TakeSubTransactions(                                   \
-      nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions) override;
+  nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions) override;		\
+  nsresult AddTransaction(nsAHttpTransaction *) override;                      \
+  uint32_t PipelineDepth() override;                                           \
+  nsresult SetPipelinePosition(int32_t) override;                              \
+  int32_t  PipelinePosition() override;
 
 //-----------------------------------------------------------------------------
 // nsAHttpSegmentReader
diff --git a/netwerk/protocol/http/nsHttp.h b/netwerk/protocol/http/nsHttp.h
index 1c988ed..e0bd4db 100644
--- a/netwerk/protocol/http/nsHttp.h
+++ b/netwerk/protocol/http/nsHttp.h
@@ -107,6 +107,9 @@ typedef uint8_t nsHttpVersion;
 // on ERROR_NET_RESET.
 #define NS_HTTP_CONNECTION_RESTARTABLE (1 << 13)
 
+//rpipeline
+#define NS_HTTP_ALLOW_PIPELINING (1 << 14)
+
 //-----------------------------------------------------------------------------
 // some default values
 //-----------------------------------------------------------------------------
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
index dcae3e1..4f276be 100644
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -900,6 +900,24 @@ nsresult nsHttpChannel::ContinueHandleAsyncFallback(nsresult rv) {
   return rv;
 }
 
+static bool
+SafeForPipelining(nsHttpRequestHead::ParsedMethodType method,
+                  const nsCString &methodString)
+{
+    if (method == nsHttpRequestHead::kMethod_Get ||
+        method == nsHttpRequestHead::kMethod_Head ||
+        method == nsHttpRequestHead::kMethod_Options) {
+        return true;
+    }
+
+    if (method != nsHttpRequestHead::kMethod_Custom) {
+        return false;
+    }
+
+    return (!strcmp(methodString.get(), "PROPFIND") ||
+            !strcmp(methodString.get(), "PROPPATCH"));
+}
+
 nsresult nsHttpChannel::SetupTransaction() {
   LOG(("nsHttpChannel::SetupTransaction [this=%p, cos=%u, prio=%d]\n", this,
        mClassOfService, mPriority));
@@ -939,6 +957,24 @@ nsresult nsHttpChannel::SetupTransaction() {
   }
 
   mUsedNetwork = 1;
+  if (mCaps & NS_HTTP_ALLOW_PIPELINING) {
+      //
+      // disable pipelining if:
+      //   (1) pipelining has been disabled by config
+      //   (2) pipelining has been disabled by connection mgr info
+      //   (3) request corresponds to a top-level document load (link click)
+      //   (4) request method is non-idempotent
+      //   (5) request is marked slow (e.g XHR)
+      //
+      nsAutoCString method;
+      mRequestHead.Method(method);
+      if (!mAllowPipelining ||
+         (mLoadFlags & (LOAD_INITIAL_DOCUMENT_URI | INHIBIT_PIPELINE)) ||
+          !SafeForPipelining(mRequestHead.ParsedMethod(), method)) {
+          LOG(("  pipelining disallowed\n"));
+          mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
+      }
+  }
 
   if (mTRR) {
     mCaps |= NS_HTTP_LARGE_KEEPALIVE;
@@ -1094,6 +1130,7 @@ nsresult nsHttpChannel::SetupTransaction() {
                                     true);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     mCaps |= NS_HTTP_STICKY_CONNECTION;
+    mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
     mCaps &= ~NS_HTTP_ALLOW_KEEPALIVE;
   }
 
@@ -3007,6 +3044,121 @@ void nsHttpChannel::HandleAsyncAbort() {
   HttpAsyncAborter<nsHttpChannel>::HandleAsyncAbort();
 }
 
+//repipeline
+nsresult
+nsHttpChannel::EnsureAssocReq()
+{
+    // Confirm Assoc-Req response header on pipelined transactions
+    // per draft-nottingham-http-pipeline-01.txt
+    // of the form: GET http://blah.com/foo/bar?qv
+    // return NS_OK as long as we don't find a violation
+    // (i.e. no header is ok, as are malformed headers, as are
+    // transactions that have not been pipelined (unless those have been
+    // opted in via pragma))
+
+    if (!mResponseHead)
+        return NS_OK;
+
+    nsAutoCString assoc_val;
+    if (NS_FAILED(mResponseHead->GetHeader(nsHttp::Assoc_Req, assoc_val))) {
+        return NS_OK;
+    }
+
+    if (!mTransaction || !mURI)
+        return NS_OK;
+
+    if (!mTransaction->PipelinePosition()) {
+        // "Pragma: X-Verify-Assoc-Req" can be used to verify even non pipelined
+        // transactions. It is used by test harness.
+
+        nsAutoCString pragma_val;
+        mResponseHead->GetHeader(nsHttp::Pragma, pragma_val);
+        if (pragma_val.IsEmpty() ||
+            !nsHttp::FindToken(pragma_val.get(), "X-Verify-Assoc-Req",
+                               HTTP_HEADER_VALUE_SEPS))
+            return NS_OK;
+    }
+
+    char *method = net_FindCharNotInSet(assoc_val.get(), HTTP_LWS);
+    if (!method)
+        return NS_OK;
+
+    bool equals;
+    char *endofmethod;
+
+    char * assoc_valChar = nullptr;
+    endofmethod = net_FindCharInSet(method, HTTP_LWS);
+    if (endofmethod)
+        assoc_valChar = net_FindCharNotInSet(endofmethod, HTTP_LWS);
+    if (!assoc_valChar)
+        return NS_OK;
+
+    // check the method
+    nsAutoCString methodHead;
+    mRequestHead.Method(methodHead);
+    if ((((int32_t)methodHead.Length()) != (endofmethod - method)) ||
+        PL_strncmp(method,
+                   methodHead.get(),
+                   endofmethod - method)) {
+        LOG(("  Assoc-Req failure Method %s", method));
+        if (mConnectionInfo)
+            gHttpHandler->ConnMgr()->
+                PipelineFeedbackInfo(mConnectionInfo,
+                                     nsHttpConnectionMgr::RedCorruptedContent,
+                                     nullptr, 0);
+
+        nsCOMPtr<nsIConsoleService> consoleService =
+            do_GetService(NS_CONSOLESERVICE_CONTRACTID);
+        if (consoleService) {
+            nsAutoString message
+                (NS_LITERAL_STRING("Failed Assoc-Req. Received "));
+            nsAutoCString assoc_req;
+            mResponseHead->GetHeader(nsHttp::Assoc_Req, assoc_req);
+            AppendASCIItoUTF16(assoc_req, message);
+            message += NS_LITERAL_STRING(" expected method ");
+            AppendASCIItoUTF16(methodHead, message);
+            consoleService->LogStringMessage(message.get());
+        }
+
+        if (gHttpHandler->EnforceAssocReq())
+            return NS_ERROR_CORRUPTED_CONTENT;
+        return NS_OK;
+    }
+
+    // check the URL
+    nsCOMPtr<nsIURI> assoc_url;
+    if (NS_FAILED(NS_NewURI(getter_AddRefs(assoc_url), assoc_valChar)) ||
+        !assoc_url)
+        return NS_OK;
+
+    mURI->Equals(assoc_url, &equals);
+    if (!equals) {
+        LOG(("  Assoc-Req failure URL %s", assoc_valChar));
+        if (mConnectionInfo)
+            gHttpHandler->ConnMgr()->
+                PipelineFeedbackInfo(mConnectionInfo,
+                                     nsHttpConnectionMgr::RedCorruptedContent,
+                                     nullptr, 0);
+
+        nsCOMPtr<nsIConsoleService> consoleService =
+            do_GetService(NS_CONSOLESERVICE_CONTRACTID);
+        if (consoleService) {
+            nsAutoString message
+                (NS_LITERAL_STRING("Failed Assoc-Req. Received "));
+            nsAutoCString assoc_req;
+            mResponseHead->GetHeader(nsHttp::Assoc_Req, assoc_req);
+            AppendASCIItoUTF16(assoc_req, message);
+            message += NS_LITERAL_STRING(" expected URL ");
+            AppendASCIItoUTF16(mSpec.get(), message);
+            consoleService->LogStringMessage(message.get());
+        }
+
+        if (gHttpHandler->EnforceAssocReq())
+            return NS_ERROR_CORRUPTED_CONTENT;
+    }
+    return NS_OK;
+}
+
 //-----------------------------------------------------------------------------
 // nsHttpChannel <byte-range>
 //-----------------------------------------------------------------------------
@@ -6065,6 +6217,13 @@ nsresult nsHttpChannel::BeginConnectContinue() {
   // clear the already recorded AsyncOpen value for consistency.
   if (!mTimingEnabled) mAsyncOpenTime = TimeStamp();
 
+    // when proxying only use the pipeline bit if ProxyPipelining() allows it. repipeline
+    if (!mConnectionInfo->UsingConnect() && mConnectionInfo->UsingHttpProxy()) {
+        mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
+        if (gHttpHandler->ProxyPipelining())
+            mCaps |= NS_HTTP_ALLOW_PIPELINING;
+    }
+
   // if this somehow fails we can go on without it
   Unused << gHttpHandler->AddConnectionHeader(&mRequestHead, mCaps);
 
@@ -6075,7 +6234,7 @@ nsresult nsHttpChannel::BeginConnectContinue() {
   //  - If "Connection: close" is set as a request header, then do not bother
   //    trying to establish a keep-alive connection.
   if (mRequestHead.HasHeaderValue(nsHttp::Connection, "close"))
-    mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE);
+    mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE | NS_HTTP_ALLOW_PIPELINING); //repipeline
 
   if (gHttpHandler->CriticalRequestPrioritization()) {
     if (mClassOfService & nsIClassOfService::Leader) {
@@ -6098,6 +6257,8 @@ nsresult nsHttpChannel::BeginConnectContinue() {
       gHttpHandler->ConnMgr()->ClearAltServiceMappings();
       rv = gHttpHandler->ConnMgr()->DoShiftReloadConnectionCleanup(
           mConnectionInfo);
+    
+      mCaps &= ~NS_HTTP_ALLOW_PIPELINING; //repipeline
       if (NS_FAILED(rv)) {
         LOG(
             ("nsHttpChannel::BeginConnect "
@@ -6910,6 +7071,16 @@ nsHttpChannel::OnStopRequest(nsIRequest *request, nsISupports *ctxt,
           conn = nullptr;
         }
       }
+
+      //repipeline
+      // We do not use a sticky connection in case of a nsHttpPipeline as
+      // well (see bug 1337826). This is a quick fix, because
+      // nsHttpPipeline is turned off by default.
+      RefPtr<nsAHttpTransaction> tranConn = do_QueryObject(conn);
+      if (tranConn && tranConn->QueryPipeline()) {
+          LOG(("Do not use this connection, it is a nsHttpPipeline."));
+          conn = nullptr;
+      }
     }
 
     RefPtr<nsAHttpConnection> stickyConn;
diff --git a/netwerk/protocol/http/nsHttpConnection.cpp b/netwerk/protocol/http/nsHttpConnection.cpp
index 70e6d8e..3a5f185 100644
--- a/netwerk/protocol/http/nsHttpConnection.cpp
+++ b/netwerk/protocol/http/nsHttpConnection.cpp
@@ -21,6 +21,7 @@
 #include "mozilla/ChaosMode.h"
 #include "mozilla/Telemetry.h"
 #include "nsHttpConnection.h"
+#include "nsHttpPipeline.h"
 #include "nsHttpHandler.h"
 #include "nsHttpRequestHead.h"
 #include "nsHttpResponseHead.h"
@@ -41,6 +42,8 @@
 namespace mozilla {
 namespace net {
 
+static LazyLogModule mylogger("httplogger"); //remember this has to be here (under namespace mozilla)
+
 //-----------------------------------------------------------------------------
 // nsHttpConnection <public>
 //-----------------------------------------------------------------------------
@@ -74,6 +77,7 @@ nsHttpConnection::nsHttpConnection()
       mTrafficStamp(false),
       mHttp1xTransactionCount(0),
       mRemainingConnectionUses(0xffffffff),
+      mClassification(nsAHttpTransaction::CLASS_GENERAL),
       mNPNComplete(false),
       mSetupSSLCalled(false),
       mUsingSpdyVersion(0),
@@ -159,11 +163,15 @@ nsresult nsHttpConnection::Init(
   mLastWriteTime = mLastReadTime = PR_IntervalNow();
   mRtt = rtt;
   mMaxHangTime = PR_SecondsToInterval(maxHangTime);
+    mSupportsPipelining =
+        gHttpHandler->ConnMgr()->SupportsPipelining(mConnInfo);
 
   mSocketTransport = transport;
   mSocketIn = instream;
   mSocketOut = outstream;
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::Init\tthis=%p\tmSocketIn=%p\tmSocketOut=%p", this, mSocketIn, mSocketOut));
+
   // See explanation for non-strictness of this operation in
   // SetSecurityCallbacks.
   mCallbacks = new nsMainThreadPtrHolder<nsIInterfaceRequestor>(
@@ -452,12 +460,16 @@ bool nsHttpConnection::EnsureNPNComplete(nsresult &aOut0RTTWriteHandshakeValue,
           ("nsHttpConnection::EnsureNPNComplete %p - "
            "early selected alpn not available",
            this));
+
+      MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::EnsureNpnComplete no early selected alpn\tthis=%p", this));
       mEarlyDataNegotiated = false;
     } else {
       LOG(
           ("nsHttpConnection::EnsureNPNComplete %p -"
            "early selected alpn: %s",
            this, mEarlyNegotiatedALPN.get()));
+
+      MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::EnsureNpnComplete early selected alpn\tthis=%p\talpn=%p", this, mEarlyNegotiatedALPN.get()));
       uint32_t infoIndex;
       const SpdyInformation *info = gHttpHandler->SpdyInfo();
       if (NS_FAILED(info->GetNPNIndex(mEarlyNegotiatedALPN, &infoIndex))) {
@@ -469,6 +481,7 @@ bool nsHttpConnection::EnsureNPNComplete(nsresult &aOut0RTTWriteHandshakeValue,
                "can do 0RTT (http/1)!",
                this));
           mWaitingFor0RTTResponse = true;
+          MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::EnsureNpnComplete 0RTT (http/1)\tthis=%p", this));
         }
       } else {
         // We have h2, we can at least 0-RTT the preamble and opening
@@ -477,6 +490,7 @@ bool nsHttpConnection::EnsureNPNComplete(nsresult &aOut0RTTWriteHandshakeValue,
             ("nsHttpConnection::EnsureNPNComplete [this=%p] - Starting "
              "0RTT for h2!",
              this));
+          MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::EnsureNpnComplete 0RTT (http/2)\tthis=%p", this));
         mWaitingFor0RTTResponse = true;
         Start0RTTSpdy(info->Version[infoIndex]);
       }
@@ -604,6 +618,8 @@ npnComplete:
        this));
   mNPNComplete = true;
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::EnsureNpnComplete\tthis=%p", this));
+
   mTransaction->OnTransportStatus(mSocketTransport,
                                   NS_NET_STATUS_TLS_HANDSHAKE_ENDED, 0);
 
@@ -668,6 +684,8 @@ nsresult nsHttpConnection::Activate(nsAHttpTransaction *trans, uint32_t caps,
   LOG(("nsHttpConnection::Activate [this=%p trans=%p caps=%x]\n", this, trans,
        caps));
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::Activate\tthis=%p\ttrans=%p", this, trans));
+
   if (!mExperienced && !trans->IsNullTransaction()) {
     if (!mFastOpen) {
       mExperienced = true;
@@ -894,6 +912,8 @@ nsresult nsHttpConnection::AddTransaction(nsAHttpTransaction *httpTransaction,
     return NS_ERROR_FAILURE;
   }
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::AddTransaction\tthis=%p\ttrans=%p\n", this, httpTransaction));
+
   Unused << ResumeSend();
   return NS_OK;
 }
@@ -902,6 +922,8 @@ void nsHttpConnection::Close(nsresult reason, bool aIsShutdown) {
   LOG(("nsHttpConnection::Close [this=%p reason=%" PRIx32 "]\n", this,
        static_cast<uint32_t>(reason)));
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnection::Close\tthis=%p\treason=%x", this, reason));
+
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
   // Ensure TCP keepalive timer is stopped.
@@ -1015,11 +1037,30 @@ bool nsHttpConnection::JoinConnection(const nsACString &hostname,
   return false;
 }
 
+// Checked by the Connection Manager before scheduling a pipelined transaction
+bool
+nsHttpConnection::SupportsPipelining()
+{
+    if (mTransaction &&
+        mTransaction->PipelineDepth() >= mRemainingConnectionUses) {
+        LOG(("nsHttpConnection::SupportsPipelining this=%p deny pipeline "
+             "because current depth %d exceeds max remaining uses %d\n",
+             this, mTransaction->PipelineDepth(), mRemainingConnectionUses));
+        return false;
+    }
+    return mSupportsPipelining && IsKeepAlive() && !mDontReuse;
+}
+
 bool nsHttpConnection::CanReuse() {
   if (mDontReuse || !mRemainingConnectionUses) {
     return false;
   }
 
+  if ((mTransaction ? mTransaction->PipelineDepth() : 0) >=
+      mRemainingConnectionUses) {
+      return false;
+  }
+
   if ((mTransaction ? (mTransaction->IsDone() ? 0U : 1U) : 0U) >=
       mRemainingConnectionUses) {
     return false;
@@ -1106,6 +1147,64 @@ bool nsHttpConnection::IsAlive() {
   return alive;
 }
 
+bool
+nsHttpConnection::SupportsPipelining(nsHttpResponseHead *responseHead)
+{
+    // SPDY supports infinite parallelism, so no need to pipeline.
+    if (mUsingSpdyVersion)
+        return false;
+
+    // assuming connection is HTTP/1.1 with keep-alive enabled
+    if (mConnInfo->UsingHttpProxy() && !mConnInfo->UsingConnect()) {
+        // XXX check for bad proxy servers...
+        return true;
+    }
+
+    // check for bad origin servers
+    nsAutoCString val;
+    responseHead->GetHeader(nsHttp::Server, val);
+
+    // If there is no server header we will assume it should not be banned
+    // as facebook and some other prominent sites do this
+    if (val.IsEmpty())
+        return true;
+
+    // The blacklist is indexed by the first character. All of these servers are
+    // known to return their identifier as the first thing in the server string,
+    // so we can do a leading match.
+
+    static const char *bad_servers[26][6] = {
+        { nullptr }, { nullptr }, { nullptr }, { nullptr },                 // a - d
+        { "EFAServer/", nullptr },                                       // e
+        { nullptr }, { nullptr }, { nullptr }, { nullptr },                 // f - i
+        { nullptr }, { nullptr }, { nullptr },                             // j - l
+        { "Microsoft-IIS/4.", "Microsoft-IIS/5.", nullptr },             // m
+        { "Netscape-Enterprise/3.", "Netscape-Enterprise/4.",
+          "Netscape-Enterprise/5.", "Netscape-Enterprise/6.", nullptr }, // n
+        { nullptr }, { nullptr }, { nullptr }, { nullptr },                 // o - r
+        { nullptr }, { nullptr }, { nullptr }, { nullptr },                 // s - v
+        { "WebLogic 3.", "WebLogic 4.","WebLogic 5.", "WebLogic 6.",
+          "Winstone Servlet Engine v0.", nullptr },                      // w
+        { nullptr }, { nullptr }, { nullptr }                              // x - z
+    };
+
+    int index = val.get()[0] - 'A'; // the whole table begins with capital letters
+    if ((index >= 0) && (index <= 25))
+    {
+        for (int i = 0; bad_servers[index][i] != nullptr; i++) {
+            if (val.Equals(bad_servers[index][i])) {
+                LOG(("looks like this server does not support pipelining"));
+                gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+                    mConnInfo, nsHttpConnectionMgr::RedBannedServer, this , 0);
+                return false;
+            }
+        }
+    }
+
+    // ok, let's allow pipelining to this server
+    return true;
+}
+
 void nsHttpConnection::SetUrgentStartPreferred(bool urgent) {
   if (mExperienced && !mUrgentStartPreferredKnown) {
     // Set only according the first ever dispatched non-null transaction
@@ -1176,6 +1275,9 @@ nsresult nsHttpConnection::OnHeadersAvailable(nsAHttpTransaction *trans,
     explicitKeepAlive = false;
   }
 
+  // reset to default (the server may have changed since we last checked)
+  mSupportsPipelining = false;
+
   if ((responseHead->Version() < NS_HTTP_VERSION_1_1) ||
       (requestHead->Version() < NS_HTTP_VERSION_1_1)) {
     // HTTP/1.0 connections are by default NOT persistent
@@ -1183,8 +1285,35 @@ nsresult nsHttpConnection::OnHeadersAvailable(nsAHttpTransaction *trans,
       mKeepAlive = true;
     else
       mKeepAlive = false;
+
+    // We need at least version 1.1 to use pipelines
+    gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+        mConnInfo, nsHttpConnectionMgr::RedVersionTooLow, this, 0);
   } else {
     // HTTP/1.1 connections are by default persistent
+
+    //repipeline:
+        if (explicitClose) {
+            mKeepAlive = false;
+
+            // persistent connections are required for pipelining to work - if
+            // this close was not pre-announced then generate the negative
+            // BadExplicitClose feedback
+            if (mRemainingConnectionUses > 1)
+                gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+                    mConnInfo, nsHttpConnectionMgr::BadExplicitClose, this, 0);
+        }
+
+    if (!explicitClose) {
+
+    // Do not support pipelining when we are establishing
+    // an SSL tunnel though an HTTP proxy. Pipelining support
+    // determination must be based on comunication with the
+    // target server in this case. See bug 422016 for futher
+    // details.
+    if (!mProxyConnectStream)
+       mSupportsPipelining = SupportsPipelining(responseHead);
+    }
     mKeepAlive = !explicitClose;
   }
   mKeepAliveMask = mKeepAlive;
@@ -1395,6 +1524,67 @@ uint32_t nsHttpConnection::ReadTimeoutTick(PRIntervalTime now) {
     nextTickAfter = std::max(nextTickAfter, 1U);
   }
 
+
+
+    if (!gHttpHandler->GetPipelineRescheduleOnTimeout())
+        return nextTickAfter;
+
+    PRIntervalTime delta = now - mLastReadTime;
+
+    // we replicate some of the checks both here and in OnSocketReadable() as
+    // they will be discovered under different conditions. The ones here
+    // will generally be discovered if we are totally hung and OSR does
+    // not get called at all, however OSR discovers them with lower latency
+    // if the issue is just very slow (but not stalled) reading.
+    //
+    // Right now we only take action if pipelining is involved, but this would
+    // be the place to add general read timeout handling if it is desired.
+
+    uint32_t pipelineDepth = mTransaction->PipelineDepth();
+    if (pipelineDepth > 1) {
+        // if we have pipelines outstanding (not just an idle connection)
+        // then get a fairly quick tick
+        nextTickAfter = 1;
+    }
+
+    if (delta >= gHttpHandler->GetPipelineRescheduleTimeout() &&
+        pipelineDepth > 1) {
+
+        // this just reschedules blocked transactions. no transaction
+        // is aborted completely.
+        LOG(("cancelling pipeline due to a %ums stall - depth %d\n",
+             PR_IntervalToMilliseconds(delta), pipelineDepth));
+
+        nsHttpPipeline *pipeline = mTransaction->QueryPipeline();
+        MOZ_ASSERT(pipeline, "pipelinedepth > 1 without pipeline");
+        // code this defensively for the moment and check for null in opt build
+        // This will reschedule blocked members of the pipeline, but the
+        // blocking transaction (i.e. response 0) will not be changed.
+        if (pipeline) {
+            pipeline->CancelPipeline(NS_ERROR_NET_TIMEOUT);
+            LOG(("Rescheduling the head of line blocked members of a pipeline "
+                 "because reschedule-timeout idle interval exceeded"));
+        }
+    }
+
+    if (delta < gHttpHandler->GetPipelineTimeout())
+        return nextTickAfter;
+
+    if (pipelineDepth <= 1 && !mTransaction->PipelinePosition())
+        return nextTickAfter;
+
+    // nothing has transpired on this pipelined socket for many
+    // seconds. Call that a total stall and close the transaction.
+    // There is a chance the transaction will be restarted again
+    // depending on its state.. that will come back araound
+    // without pipelining on, so this won't loop.
+
+    LOG(("canceling transaction stalled for %ums on a pipeline "
+         "of depth %d and scheduled originally at pos %d\n",
+         PR_IntervalToMilliseconds(delta),
+         pipelineDepth, mTransaction->PipelinePosition()));
+
+
   // Check for the TCP Fast Open related stalls.
   if (mCheckNetworkStallsWithTFO && mLastRequestBytesSentTime) {
     PRIntervalTime initialResponseDelta = now - mLastRequestBytesSentTime;
diff --git a/netwerk/protocol/http/nsHttpConnection.h b/netwerk/protocol/http/nsHttpConnection.h
index b191f25..726749d 100644
--- a/netwerk/protocol/http/nsHttpConnection.h
+++ b/netwerk/protocol/http/nsHttpConnection.h
@@ -100,6 +100,7 @@ class nsHttpConnection final : public nsAHttpSegmentReader,
   //-------------------------------------------------------------------------
   // XXX document when these are ok to call
 
+  bool SupportsPipelining();
   bool IsKeepAlive() {
     return mUsingSpdyVersion || (mKeepAliveMask && mKeepAlive);
   }
@@ -197,6 +198,12 @@ class nsHttpConnection final : public nsAHttpSegmentReader,
   // should move from short-lived (fast-detect) to long-lived.
   static void UpdateTCPKeepalive(nsITimer *aTimer, void *aClosure);
 
+    nsAHttpTransaction::Classifier Classification() { return mClassification; }
+    void Classify(nsAHttpTransaction::Classifier newclass)
+    {
+        mClassification = newclass;
+    }
+
   // When the connection is active this is called every second
   void ReadTimeoutTick();
 
@@ -267,6 +274,7 @@ class nsHttpConnection final : public nsAHttpSegmentReader,
 
   PRIntervalTime IdleTime();
   bool IsAlive();
+bool     SupportsPipelining(nsHttpResponseHead *);
 
   // Makes certain the SSL handshake is complete and NPN negotiation
   // has had a chance to happen
@@ -343,6 +351,7 @@ class nsHttpConnection final : public nsAHttpSegmentReader,
   bool mKeepAlive;
   bool mKeepAliveMask;
   bool mDontReuse;
+  bool mSupportsPipelining;
   bool mIsReused;
   bool mCompletedProxyConnect;
   bool mLastTransactionExpectedNoContent;
@@ -365,6 +374,8 @@ class nsHttpConnection final : public nsAHttpSegmentReader,
   // on this persistent connection.
   uint32_t mRemainingConnectionUses;
 
+  nsAHttpTransaction::Classifier  mClassification;
+
   // SPDY related
   bool mNPNComplete;
   bool mSetupSSLCalled;
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index 65998da..da2ea7e 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -14,6 +14,7 @@
 
 #include "nsHttpConnectionMgr.h"
 #include "nsHttpConnection.h"
+#include "nsHttpPipeline.h"
 #include "nsHttpHandler.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsNetCID.h"
@@ -36,6 +37,11 @@
 #include "mozilla/Unused.h"
 #include "nsIURI.h"
 
+//blast:
+#include "sys/time.h" 
+#include "mozilla/Logging.h" 
+#include <string> 
+
 #include "mozilla/Move.h"
 #include "mozilla/Telemetry.h"
 
@@ -169,7 +175,9 @@ nsresult nsHttpConnectionMgr::EnsureSocketThreadTarget() {
 nsresult nsHttpConnectionMgr::Init(
     uint16_t maxUrgentExcessiveConns, uint16_t maxConns,
     uint16_t maxPersistConnsPerHost, uint16_t maxPersistConnsPerProxy,
-    uint16_t maxRequestDelay, bool throttleEnabled, uint32_t throttleVersion,
+    uint16_t maxRequestDelay, 
+    uint16_t maxPipelinedRequests, uint16_t maxOptimisticPipelinedRequests, uint32_t PipeliningPolicy,
+    bool throttleEnabled, uint32_t throttleVersion,
     uint32_t throttleSuspendFor, uint32_t throttleResumeFor,
     uint32_t throttleReadLimit, uint32_t throttleReadInterval,
     uint32_t throttleHoldTime, uint32_t throttleMaxTime) {
@@ -183,6 +191,9 @@ nsresult nsHttpConnectionMgr::Init(
     mMaxPersistConnsPerHost = maxPersistConnsPerHost;
     mMaxPersistConnsPerProxy = maxPersistConnsPerProxy;
     mMaxRequestDelay = maxRequestDelay;
+    mMaxPipelinedRequests = maxPipelinedRequests;
+    mMaxOptimisticPipelinedRequests = maxOptimisticPipelinedRequests;
+    mPipeliningPolicy = PipeliningPolicy;
 
     mThrottleEnabled = throttleEnabled;
     mThrottleVersion = throttleVersion;
@@ -445,6 +456,8 @@ nsresult nsHttpConnectionMgr::SpeculativeConnect(
   MOZ_ASSERT(NS_IsMainThread(),
              "nsHttpConnectionMgr::SpeculativeConnect called off main thread!");
 
+    LOG(("f=nsHttpConnectionMgr::SpeculativeConnect called\tci=%s\n", ci->HashKey().get()));
+
   if (!IsNeckoChild()) {
     // HACK: make sure PSM gets initialized on the main thread.
     net_EnsurePSMInit();
@@ -1066,6 +1079,51 @@ bool nsHttpConnectionMgr::ProcessPendingQForEntry(nsConnectionEntry *ent,
                                                   bool considerAll) {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
+
+    //blast
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::ProcessPendingQForEntry called\tent=%p\tci=%s\n", ent, ent->mConnInfo->HashKey().get()));
+    for (int i = 0; i < ent->mUrgentStartQ.Length(); i++) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("q=mUrgentStartQ\tnum=(%d/%d)\tent=%p\ttrans=%p\n", i, ent->mUrgentStartQ.Length(), ent, ent->mUrgentStartQ[i].get()));
+    }
+    int pendcount = 0;
+    for (auto it = ent->mPendingTransactionTable.Iter(); !it.Done(); it.Next()) {
+      for (auto info : *it.UserData()) {
+        pendcount += 1;
+      }
+    }
+
+    char* queuestr;
+    queuestr = (char*)malloc(17 * pendcount + 1 + 20); //length of a address is 12 bytes
+    strcpy(queuestr, "q=mPendingTrans\t");
+
+    for (auto it = ent->mPendingTransactionTable.Iter(); !it.Done(); it.Next()) {
+      for (auto info : *it.UserData()) {
+        char* this_queuestr;
+        this_queuestr = (char*)malloc(16);
+        sprintf(this_queuestr, "%p ", info->mTransaction.get());
+        strcat(queuestr, this_queuestr);
+      }
+    }
+
+    MOZ_LOG(mylogger, LogLevel::Debug, ("%s", queuestr));
+    /*
+
+    for (auto it = ent->mPendingTransactionTable.Iter(); !it.Done(); it.Next()) {
+      MOZ_LOG(mylogger, LogLevel::Debug, ("window id = %" PRIx64 " queue:", it.Key()));
+      for (auto info : *it.UserData()) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("%p", info->mTransaction.get()));
+      }
+    }*/
+    for (int i = 0; i < ent->mActiveConns.Length(); i++) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("q=mActiveConns\tnum=(%d/%d)\tent=%p\tconn=%p\n", i, ent->mActiveConns.Length(), ent, ent->mActiveConns[i].get()));
+    }
+    for (int i = 0; i < ent->mIdleConns.Length(); i++) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("q=mIdleConns\tnum=(%d/%d)\tent=%p\tconn=%p\n", i, ent->mIdleConns.Length(), ent, ent->mIdleConns[i].get()));
+    }
+    for (int i = 0; i < ent->mHalfOpens.Length(); i++) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("q=mHalfOpens\tnum=(%d/%d)\tent=%p\tconn=%p\n", i, ent->mHalfOpens.Length(), ent, ent->mHalfOpens[i])); //repipeline: this is already a pointer, not a RefPtr
+    }
+
   LOG(
       ("nsHttpConnectionMgr::ProcessPendingQForEntry "
        "[ci=%s ent=%p active=%zu idle=%zu urgent-start-queue=%zu"
@@ -1162,6 +1220,116 @@ bool nsHttpConnectionMgr::ProcessPendingQForEntry(nsHttpConnectionInfo *ci) {
   return false;
 }
 
+bool
+nsHttpConnectionMgr::SupportsPipelining(nsHttpConnectionInfo *ci)
+{
+    MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+
+    nsConnectionEntry *ent = mCT.GetWeak(ci->HashKey());
+    if (ent)
+        return ent->SupportsPipelining();
+    return false;
+}
+
+// nsHttpPipelineFeedback used to hold references across events
+
+class nsHttpPipelineFeedback : public ARefBase
+{
+public:
+    nsHttpPipelineFeedback(nsHttpConnectionInfo *ci,
+                           nsHttpConnectionMgr::PipelineFeedbackInfoType info,
+                           nsHttpConnection *conn, uint32_t data)
+        : mConnInfo(ci)
+        , mConn(conn)
+        , mInfo(info)
+        , mData(data)
+        {
+        }
+
+
+    RefPtr<nsHttpConnectionInfo> mConnInfo;
+    RefPtr<nsHttpConnection> mConn;
+    nsHttpConnectionMgr::PipelineFeedbackInfoType mInfo;
+    uint32_t mData;
+private:
+    ~nsHttpPipelineFeedback() {}
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(nsHttpPipelineFeedback)
+};
+
+void
+nsHttpConnectionMgr::PipelineFeedbackInfo(nsHttpConnectionInfo *ci,
+                                          PipelineFeedbackInfoType info,
+                                          nsHttpConnection *conn,
+                                          uint32_t data)
+{
+    if (!ci)
+        return;
+
+    // Post this to the socket thread if we are not running there already //repipeline: replaced check
+  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+//    if (PR_GetCurrentThread() != gSocketThread) {
+    if (!OnSocketThread()) {
+        RefPtr<nsHttpPipelineFeedback> fb =
+            new nsHttpPipelineFeedback(ci, info, conn, data);
+        PostEvent(&nsHttpConnectionMgr::OnMsgProcessFeedback, 0, fb);
+        return;
+    }
+
+    nsConnectionEntry *ent = mCT.GetWeak(ci->HashKey());
+    if (ent)
+        ent->OnPipelineFeedbackInfo(info, conn, data);
+}
+
+void
+nsHttpConnectionMgr::ReportFailedToProcess(nsIURI *uri)
+{
+    MOZ_ASSERT(uri);
+
+    nsAutoCString host;
+    int32_t port = -1;
+    nsAutoCString username;
+    bool usingSSL = false;
+    bool isHttp = false;
+
+    nsresult rv = uri->SchemeIs("https", &usingSSL);
+    if (NS_SUCCEEDED(rv) && usingSSL)
+        isHttp = true;
+    if (NS_SUCCEEDED(rv) && !isHttp)
+        rv = uri->SchemeIs("http", &isHttp);
+    if (NS_SUCCEEDED(rv))
+        rv = uri->GetAsciiHost(host);
+    if (NS_SUCCEEDED(rv))
+        rv = uri->GetPort(&port);
+    if (NS_SUCCEEDED(rv))
+        uri->GetUsername(username);
+    if (NS_FAILED(rv) || !isHttp || host.IsEmpty())
+        return;
+
+    // report the event for all the permutations of anonymous and
+    // private versions of this host
+    RefPtr<nsHttpConnectionInfo> ci =
+        new nsHttpConnectionInfo(host, port, EmptyCString(), username, nullptr,
+                                 OriginAttributes(), usingSSL);
+    ci->SetAnonymous(false);
+    ci->SetPrivate(false);
+    PipelineFeedbackInfo(ci, RedCorruptedContent, nullptr, 0);
+
+    ci = ci->Clone();
+    ci->SetAnonymous(false);
+    ci->SetPrivate(true);
+    PipelineFeedbackInfo(ci, RedCorruptedContent, nullptr, 0);
+
+    ci = ci->Clone();
+    ci->SetAnonymous(true);
+    ci->SetPrivate(false);
+    PipelineFeedbackInfo(ci, RedCorruptedContent, nullptr, 0);
+
+    ci = ci->Clone();
+    ci->SetAnonymous(true);
+    ci->SetPrivate(true);
+    PipelineFeedbackInfo(ci, RedCorruptedContent, nullptr, 0);
+}
+
 // we're at the active connection limit if any one of the following conditions
 // is true:
 //  (1) at max-connections
@@ -1292,6 +1460,8 @@ nsresult nsHttpConnectionMgr::MakeNewConnection(
     nsConnectionEntry *ent, PendingTransactionInfo *pendingTransInfo) {
   nsHttpTransaction *trans = pendingTransInfo->mTransaction;
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::MakeNewConnection\tent=%p\ttrans=%p", ent, trans));
+
   LOG(("nsHttpConnectionMgr::MakeNewConnection %p ent=%p trans=%p", this, ent,
        trans));
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
@@ -1404,6 +1574,8 @@ nsresult nsHttpConnectionMgr::MakeNewConnection(
   if (AtActiveConnectionLimit(ent, trans->Caps()))
     return NS_ERROR_NOT_AVAILABLE;
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::MakeNewConnection CreateTransport\tent=%p\ttrans=%p", ent, trans));
+
   nsresult rv =
       CreateTransport(ent, trans, trans->Caps(), false, false,
                       trans->ClassOfService() & nsIClassOfService::UrgentStart,
@@ -1422,6 +1594,192 @@ nsresult nsHttpConnectionMgr::MakeNewConnection(
   return NS_OK;
 }
 
+bool
+nsHttpConnectionMgr::AddToBestPipeline(nsConnectionEntry *ent,
+                                           nsHttpTransaction *trans,
+                                           nsHttpTransaction::Classifier classification,
+                                           uint16_t depthLimit)
+{
+
+    MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpConnectionMgr::AddToBestPipeline start\ttrans=%p", trans));
+
+    if (classification == nsAHttpTransaction::CLASS_SOLO)
+        return false;
+
+    uint32_t maxdepth = ent->MaxPipelineDepth(classification);
+    if (maxdepth == 0) {
+        maxdepth = ent->MaxPipelineDepth(classification);
+    }
+
+    if (ent->PipelineState() == PS_RED) {
+        MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpConnectionMgr::AddToBestPipeline entry is in PS_RED\ttrans=%p", trans));
+        return false;
+    }
+
+    // repipeline: with the exception of a few big errors, we always go for PS_GREEN. 
+
+    maxdepth = std::min<uint32_t>(maxdepth, depthLimit);
+    bool evenpipelines = true; 
+    //bool loosemax = true;
+
+    // Pipelining policies (mPipeliningPolicy):
+    // 1: evenpipelines is false, we always try to send on the first connection
+    // 2: evenpipelines is true, we try to send on the lowest PipelineDepth connection
+
+    /*switch (mPipeliningPolicy) {
+        case 1:
+            evenpipelines = true;
+            loosemax = false;
+        case 2:
+            evenpipelines = false;
+            loosemax = false;
+        case 3:
+            evenpipelines = true;
+        default:
+            evenpipelines = true;
+    }*/
+    
+
+    if (maxdepth < 2)
+        return false;
+
+    // Find out how many requests of this class we have
+    uint32_t sameClass = 0;
+    uint32_t allClasses = 0;
+/*
+    uint32_t allClasses = ent->mPendingQ.Length();
+    for (uint32_t i = 0; i < allClasses; ++i) {
+        if (trans != ent->mPendingQ[i] &&
+            classification == ent->mPendingQ[i]->Classification()) {
+            sameClass++;
+        }
+    }
+*/
+
+
+    for (auto it = ent->mPendingTransactionTable.Iter(); !it.Done(); it.Next()) {
+      for (auto info : *it.UserData()) {
+        nsHttpTransaction * mytrans = info->mTransaction;
+        allClasses++;
+        if (trans != mytrans && classification == mytrans->Classification()) sameClass++; 
+      }
+    }
+
+    nsAHttpTransaction *activeTrans;
+    nsHttpPipeline *pipeline;
+    nsHttpConnection *bestConn = nullptr;
+    uint32_t activeCount = ent->mActiveConns.Length();
+    uint32_t pipelineDepth;
+    uint32_t requestLen;
+    //uint32_t totalDepth = 0;
+
+    // Now, try to find the best pipeline
+    nsTArray<nsHttpConnection *> validConns;
+    nsTArray<nsHttpConnection *> betterConns;
+    nsTArray<nsHttpConnection *> bestConns;
+    uint32_t minpipelineDepth = 10000;
+    //uint32_t numPipelines = 0;
+
+    for (uint32_t i = 0; i < activeCount; ++i) {
+        nsHttpConnection *conn = ent->mActiveConns[i];
+
+        if (!conn->SupportsPipelining())
+            continue;
+
+        activeTrans = conn->Transaction();
+
+        if (!activeTrans ||
+            activeTrans->IsDone() ||
+            NS_FAILED(activeTrans->Status())) {
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpConnectionMgr::AddToBestPipeline cannot find activeTrans for conn\ttrans=%p\tconn=%p", trans, conn));
+            continue;
+
+        }
+
+        pipeline = activeTrans->QueryPipeline();
+        if (!pipeline) {
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpConnectionMgr::AddToBestPipeline cannot query pipeline for active trans\ttrans=%p\tconn=%p", trans, conn));
+            continue;
+        }
+
+        //numPipelines++;
+
+        pipelineDepth = activeTrans->PipelineDepth(); //request + response length
+        requestLen = pipeline->RequestDepth(); //only request length
+
+        //totalDepth += pipelineDepth;
+
+        // If we're within striking distance of our pipeline
+        // packaging goal, give a little slack on the depth
+        // limit to allow us to try to get there. Don't give
+        // too much slack, though, or we'll tend to have
+        // request packages of the same size when we have
+        // many content elements appear at once.
+        if (maxdepth +
+              PR_MIN(mMaxOptimisticPipelinedRequests,
+                     requestLen + allClasses)
+              <= pipelineDepth)
+            continue;
+        validConns.AppendElement(conn);
+
+        if (!conn->ContentBytesWritten()) {
+            continue;
+        }
+        if (minpipelineDepth > pipelineDepth) minpipelineDepth = pipelineDepth;
+        betterConns.AppendElement(conn); //always prefer a pipeline that is completely negotiated
+        
+        
+        /*// Prefer a pipeline that either has at least two requests
+        // queued already, or for which we can add multiple requests
+        if (requestLen + allClasses < mMaxOptimisticPipelinedRequests)
+            continue;
+
+        betterConns.AppendElement(conn);
+
+        // Prefer a pipeline with the same classification if
+        // our current classes will put it over the line
+        if (conn->Classification() != classification)
+            continue;
+        if (requestLen + sameClass < mMaxOptimisticPipelinedRequests)
+            continue;
+
+        bestConns.AppendElement(conn);*/
+    }
+
+    if (evenpipelines == true) {
+        for (uint32_t i = 0; i < betterConns.Length(); i++) {
+            nsHttpConnection *conn = betterConns[i];
+            activeTrans = conn->Transaction();
+            pipelineDepth = activeTrans->PipelineDepth();
+            if (pipelineDepth == minpipelineDepth) bestConns.AppendElement(conn);
+        }
+    }
+
+    if (bestConns.Length()) {
+        bestConn = bestConns[0]; //repipeline: remove randomness here
+        MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::AddToBestPipeline chose best conn\ttrans=%p\tconn=%p", trans, bestConn));
+    } else if (betterConns.Length()) {
+        bestConn = betterConns[0];
+        MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::AddToBestPipeline chose better conn\ttrans=%p\tconn=%p", trans, bestConn));
+    } else if (validConns.Length()) { //remove check for totalDepth here: valid conns are just valid. 
+        // We only use valid conns if it's a last resort
+        // (No other requests are pending or in flight)
+        bestConn = validConns[0];
+        MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::AddToBestPipeline chose valid conn\ttrans=%p\tconn=%p", trans, bestConn));
+    } else {
+        return false;
+    }
+
+    activeTrans = bestConn->Transaction();
+    nsresult rv = activeTrans->AddTransaction(trans);
+    if (NS_FAILED(rv))
+        return false;
+
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::AddToBestPipeline\ttrans=%p\tactiveTrans=%p\tconn=%p", trans, activeTrans, bestConn));
+
+    return true;
+}
+
 // returns OK if a connection is found for the transaction
 //   and the transaction is started.
 // returns ERROR_NOT_AVAILABLE if no connection can be found and it
@@ -1435,6 +1793,8 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
 
   nsHttpTransaction *trans = pendingTransInfo->mTransaction;
 
+  MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction\tent=%p\ttrans=%p", ent, trans));
+
   LOG(
       ("nsHttpConnectionMgr::TryDispatchTransaction without conn "
        "[trans=%p halfOpen=%p conn=%p ci=%p ci=%s caps=%x tunnelprovider=%p "
@@ -1463,6 +1823,18 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
 
   RefPtr<nsHttpConnection> unusedSpdyPersistentConnection;
 
+
+
+    // repipeline: step -1: Try a pipeline
+
+    nsHttpTransaction::Classifier classification = trans->Classification();
+    if (caps & NS_HTTP_ALLOW_PIPELINING &&
+        AddToBestPipeline(ent, trans, classification,
+                          mMaxPipelinedRequests)) {
+        MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction -1 Pipeline\tent=%p\ttrans=%p", ent, trans));
+        return NS_OK;
+    }
+
   // step 0
   // look for existing spdy connection - that's always best because it is
   // essentially pipelining without head of line blocking
@@ -1472,6 +1844,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
     if (conn) {
       if ((caps & NS_HTTP_ALLOW_KEEPALIVE) || !conn->IsExperienced()) {
         LOG(("   dispatch to spdy: [conn=%p]\n", conn.get()));
+        MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 0 SPDY\tent=%p\ttrans=%p\tconn=%p", ent, trans, conn.get()));
         trans->RemoveDispatchedAsBlocking(); /* just in case */
         nsresult rv = DispatchTransaction(ent, trans, conn);
         NS_ENSURE_SUCCESS(rv, rv);
@@ -1496,6 +1869,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
           // need to wait for blockers to clear
           LOG(("   blocked by request context: [rc=%p trans=%p blockers=%d]\n",
                requestContext, trans, blockers));
+          MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 0 context blocked\tent=%p\ttrans=%p", ent, trans));
           return NS_ERROR_NOT_AVAILABLE;
         }
       }
@@ -1530,6 +1904,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
       }
     }
     if (!runNow) {
+      MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 1 rate pacing blocked\tent=%p\ttrans=%p", ent, trans));
       LOG(("   blocked due to rate pacing trans=%p\n", trans));
       return NS_ERROR_NOT_AVAILABLE;
     }
@@ -1539,6 +1914,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
   // consider an idle persistent connection
   bool idleConnsAllUrgent = false;
   if (caps & NS_HTTP_ALLOW_KEEPALIVE) {
+    MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 2\tent=%p\ttrans=%p", ent, trans));
     nsresult rv = TryDispatchTransactionOnIdleConn(ent, pendingTransInfo, true,
                                                    &idleConnsAllUrgent);
     if (NS_SUCCEEDED(rv)) {
@@ -1553,6 +1929,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
 
   // step 4
   if (!onlyReusedConnection) {
+    MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 4 MakeNewConnection\tent=%p\ttrans=%p", ent, trans));
     nsresult rv = MakeNewConnection(ent, pendingTransInfo);
     if (NS_SUCCEEDED(rv)) {
       // this function returns NOT_AVAILABLE for asynchronous connects
@@ -1575,6 +1952,7 @@ nsresult nsHttpConnectionMgr::TryDispatchTransaction(
     if (!(trans->ClassOfService() & nsIClassOfService::UrgentStart) &&
         idleConnsAllUrgent &&
         ent->mActiveConns.Length() < MaxPersistConnections(ent)) {
+      MOZ_LOG(mylogger, LogLevel::Verbose, ("f=nsHttpConnectionMgr::TryDispatchTransaction 4-2\tent=%p\ttrans=%p", ent, trans));
       rv = TryDispatchTransactionOnIdleConn(ent, pendingTransInfo, false);
       if (NS_SUCCEEDED(rv)) {
         LOG(("   dispatched step 2a (idle, reuse urgent) trans=%p\n", trans));
@@ -1612,6 +1990,8 @@ nsresult nsHttpConnectionMgr::TryDispatchTransactionOnIdleConn(
   nsHttpTransaction *trans = pendingTransInfo->mTransaction;
   bool urgentTrans = trans->ClassOfService() & nsIClassOfService::UrgentStart;
 
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::TryDispatchTransactionOnIdleConn\tent=%p\ttrans=%p", ent, trans));
+
   LOG(
       ("nsHttpConnectionMgr::TryDispatchTransactionOnIdleConn, ent=%p, "
        "trans=%p, urgent=%d",
@@ -1676,6 +2056,8 @@ nsresult nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
   int32_t priority = trans->Priority();
   nsresult rv;
 
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::DispatchTransaction\tent=%p\tent->mUsingSpdy=%d\tconn->UsingSpdy=%d\ttrans=%p\tconn=%p", ent, (int)ent->mUsingSpdy, (int)conn->UsingSpdy(), trans, conn));
+
   LOG(
       ("nsHttpConnectionMgr::DispatchTransaction "
        "[ent-ci=%s %p trans=%p caps=%x conn=%p priority=%d]\n",
@@ -1687,6 +2069,7 @@ nsresult nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
   trans->CancelPacing(NS_OK);
 
   if (conn->UsingSpdy()) {
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::DispatchTransaction UsingSpdy\tent=%p\ttrans=%p\tconn=%p", ent, trans, conn));
     LOG(
         ("Spdy Dispatch Transaction via Activate(). Transaction host = %s, "
          "Connection host = %s\n",
@@ -1704,6 +2087,11 @@ nsresult nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
   MOZ_ASSERT(conn && !conn->Transaction(),
              "DispatchTranaction() on non spdy active connection");
 
+    if (!(caps & NS_HTTP_ALLOW_PIPELINING))
+        conn->Classify(nsAHttpTransaction::CLASS_SOLO);
+    else
+        conn->Classify(trans->Classification());
+
   rv = DispatchAbstractTransaction(ent, trans, caps, conn, priority);
 
   if (NS_SUCCEEDED(rv) && !trans->GetPendingTime().IsNull()) {
@@ -1772,13 +2160,30 @@ nsresult nsHttpConnectionMgr::DispatchAbstractTransaction(
        "[ci=%s trans=%p caps=%x conn=%p]\n",
        ent->mConnInfo->HashKey().get(), aTrans, caps, conn));
 
-  RefPtr<nsAHttpTransaction> transaction(aTrans);
+  RefPtr<nsAHttpTransaction> transaction;
+
+
+  if (conn->Classification() != nsAHttpTransaction::CLASS_SOLO) {
+        LOG(("   using pipeline datastructure.\n"));
+        RefPtr<nsHttpPipeline> pipeline;
+        rv = BuildPipeline(ent, aTrans, getter_AddRefs(pipeline));
+        if (!NS_SUCCEEDED(rv))
+            return rv;
+        transaction = pipeline;
+  }
+  else {
+    transaction = aTrans;
+  }
+
   RefPtr<ConnectionHandle> handle = new ConnectionHandle(conn);
 
   // give the transaction the indirect reference to the connection.
   transaction->SetConnection(handle);
 
   rv = conn->Activate(transaction, caps, priority);
+
+  MOZ_LOG(mylogger, LogLevel::Debug, ("f=DispatchAbstractTransaction\taTrans=%p\ttransaction=%p\tconn=%p\tent=%p", aTrans, transaction, conn, ent));
+
   if (NS_FAILED(rv)) {
     LOG(("  conn->Activate failed [rv=%" PRIx32 "]\n",
          static_cast<uint32_t>(rv)));
@@ -1795,6 +2200,25 @@ nsresult nsHttpConnectionMgr::DispatchAbstractTransaction(
   return rv;
 }
 
+nsresult
+nsHttpConnectionMgr::BuildPipeline(nsConnectionEntry *ent,
+                                   nsAHttpTransaction *firstTrans,
+                                   nsHttpPipeline **result)
+{  
+    MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+
+    /* form a pipeline here even if nothing is pending so that we
+       can stream-feed it as new transactions arrive */
+
+    /* the first transaction can go in unconditionally - 1 transaction
+       on a nsHttpPipeline object is not a real HTTP pipeline */
+
+    RefPtr<nsHttpPipeline> pipeline = new nsHttpPipeline();
+    pipeline->AddTransaction(firstTrans);
+    pipeline.forget(result);
+    return NS_OK;
+}
+
 void nsHttpConnectionMgr::ReportProxyTelemetry(nsConnectionEntry *ent) {
   enum { PROXY_NONE = 1, PROXY_HTTP = 2, PROXY_SOCKS = 3, PROXY_HTTPS = 4 };
 
@@ -1824,6 +2248,7 @@ nsresult nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans) {
 
   Http2PushedStream *pushedStream = trans->GetPushedStream();
   if (pushedStream) {
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::ProcessNewTransaction h2 session push\ttrans=%p\tstream=%p", trans, pushedStream->Session()));
     LOG(("  ProcessNewTransaction %p tied to h2 session push %p\n", trans,
          pushedStream->Session()));
     return pushedStream->Session()->AddStream(trans, trans->Priority(), false,
@@ -1873,9 +2298,13 @@ nsresult nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans) {
     }
 
     trans->SetConnection(nullptr);
+
+    MOZ_LOG(mylogger, LogLevel::Info,("f=nsHttpConnectionMgr::ProcessNewTransaction\ttrans=%p\tconn=%p", trans, conn));
     rv = DispatchTransaction(ent, trans, conn);
   } else {
     pendingTransInfo = new PendingTransactionInfo(trans);
+
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::ProcessNewTransaction\ttrans=%p\tconn=NULL", trans));
     rv = TryDispatchTransaction(ent, !!trans->TunnelProvider(),
                                 pendingTransInfo);
   }
@@ -2068,6 +2497,8 @@ void nsHttpConnectionMgr::ProcessSpdyPendingQ(nsConnectionEntry *ent) {
 
 void nsHttpConnectionMgr::OnMsgProcessAllSpdyPendingQ(int32_t, ARefBase *) {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=OnMsgProcessAllSpdyPendingQ"));
   LOG(("nsHttpConnectionMgr::OnMsgProcessAllSpdyPendingQ\n"));
   for (auto iter = mCT.Iter(); !iter.Done(); iter.Next()) {
     ProcessSpdyPendingQ(iter.Data().get());
@@ -2426,6 +2857,7 @@ void nsHttpConnectionMgr::OnMsgProcessPendingQ(int32_t, ARefBase *param) {
   nsHttpConnectionInfo *ci = static_cast<nsHttpConnectionInfo *>(param);
 
   if (!ci) {
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::OnMsgProcessPendingQ\tci=NULL"));
     LOG(("nsHttpConnectionMgr::OnMsgProcessPendingQ [ci=nullptr]\n"));
     // Try and dispatch everything
     for (auto iter = mCT.Iter(); !iter.Done(); iter.Next()) {
@@ -2434,6 +2866,7 @@ void nsHttpConnectionMgr::OnMsgProcessPendingQ(int32_t, ARefBase *param) {
     return;
   }
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::OnMsgProcessPendingQ\tci=%s", ci->HashKey().get()));
   LOG(("nsHttpConnectionMgr::OnMsgProcessPendingQ [ci=%s]\n",
        ci->HashKey().get()));
 
@@ -2697,6 +3130,8 @@ void nsHttpConnectionMgr::OnMsgReclaimConnection(int32_t, ARefBase *param) {
   MOZ_ASSERT(ent);
   RefPtr<nsHttpConnectionInfo> ci(ent->mConnInfo);
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::OnMsgReclaimConnection\tconn=%p\tent=%p", conn, ent));
+
   LOG(("nsHttpConnectionMgr::OnMsgReclaimConnection [ent=%p conn=%p]\n", ent,
        conn));
 
@@ -2746,6 +3181,8 @@ void nsHttpConnectionMgr::OnMsgReclaimConnection(int32_t, ARefBase *param) {
     mNumIdleConns++;
     conn->BeginIdleMonitoring();
 
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::OnMsgReclaimConnection made conn idle\tconn=%p\tent=%p", conn, ent));
+
     // If the added connection was first idle connection or has shortest
     // time to live among the watched connections, pruning dead
     // connections needs to be done when it can't be reused anymore.
@@ -2757,6 +3194,8 @@ void nsHttpConnectionMgr::OnMsgReclaimConnection(int32_t, ARefBase *param) {
     conn->Close(NS_ERROR_ABORT);
   }
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::OnMsgReclaimConnection calls OnMsgProcessPendingQ\tconn=%p\tent=%p\tmConnInfo=%p", conn, ent, ci));
+
   OnMsgProcessPendingQ(0, ci);
 }
 
@@ -2810,6 +3249,12 @@ void nsHttpConnectionMgr::OnMsgUpdateParam(int32_t inParam, ARefBase *) {
     case MAX_REQUEST_DELAY:
       mMaxRequestDelay = value;
       break;
+    case MAX_PIPELINED_REQUESTS:
+        mMaxPipelinedRequests = value;
+        break;
+    case MAX_OPTIMISTIC_PIPELINED_REQUESTS:
+        mMaxOptimisticPipelinedRequests = value;
+        break;
     case THROTTLING_ENABLED:
       SetThrottlingEnabled(!!value);
       break;
@@ -2851,6 +3296,14 @@ nsHttpConnectionMgr::nsConnectionEntry::~nsConnectionEntry() {
   MOZ_COUNT_DTOR(nsConnectionEntry);
 }
 
+void
+nsHttpConnectionMgr::OnMsgProcessFeedback(int32_t, ARefBase *param)
+{  
+    MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+    nsHttpPipelineFeedback *fb = static_cast<nsHttpPipelineFeedback *>(param);
+    PipelineFeedbackInfo(fb->mConnInfo, fb->mInfo, fb->mConn, fb->mData);
+}
+
 // Read Timeout Tick handlers
 
 void nsHttpConnectionMgr::ActivateTimeoutTick() {
@@ -3753,6 +4206,29 @@ void nsHttpConnectionMgr::OnMsgSpeculativeConnect(int32_t, ARefBase *param) {
   }
 }
 
+bool
+nsHttpConnectionMgr::HasPipelines(nsConnectionEntry *ent)
+{
+    uint32_t activeCount = ent->mActiveConns.Length();
+
+    if (!ent->SupportsPipelining()) {
+        return false;
+    }
+
+    for (uint32_t i = 0; i < activeCount; ++i) {
+        nsHttpConnection *conn = ent->mActiveConns[i];
+        if (!conn->SupportsPipelining())
+            continue;
+
+        nsAHttpTransaction *activeTrans = conn->Transaction();
+
+        if (activeTrans && !activeTrans->IsDone() &&
+            !NS_FAILED(activeTrans->Status()))
+            return true;
+    }
+    return false;
+}
+
 bool ConnectionHandle::IsPersistent() { return mConn->IsPersistent(); }
 
 bool ConnectionHandle::IsReused() { return mConn->IsReused(); }
@@ -4169,6 +4645,8 @@ nsHttpConnectionMgr::nsHalfOpenSocket::OnOutputStreamReady(
   mEnt->mDoNotDestroy = true;
   gHttpHandler->ConnMgr()->RecvdConnect();
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::nsHalfOpenSocket::OnOutputStreamReady\tthis=%p\toutputstream=%p\tmTransaction=%p\tmEnt=%p\n", this, out, mTransaction, mEnt));
+
   CancelBackupTimer();
 
   if (mFastOpenInProgress) {
@@ -4577,6 +5055,8 @@ nsresult nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn(
        "Created new nshttpconnection %p\n",
        conn.get()));
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn\tout=%p\tconn=%p\tconn.get=%p", out, conn, conn.get()));
+
   NullHttpTransaction *nullTrans = mTransaction->QueryNullTransaction();
   if (nullTrans) {
     conn->BootstrapTimings(nullTrans->Timings());
@@ -4666,6 +5146,9 @@ nsresult nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn(
   if (pendingTransInfo) {
     MOZ_ASSERT(!mSpeculative, "Speculative Half Open found mTransaction");
 
+    MOZ_LOG(mylogger, LogLevel::Info, 
+            ("f=nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn called DispatchTransaction\tout=%p\ttrans=%p\tconn=%p\tconn.get=%p", out, pendingTransInfo->mTransaction, conn));
+
     gHttpHandler->ConnMgr()->AddActiveConn(conn, mEnt);
     rv = gHttpHandler->ConnMgr()->DispatchTransaction(
         mEnt, pendingTransInfo->mTransaction, conn);
@@ -4699,6 +5182,9 @@ nsresult nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn(
         trans = new NullHttpTransaction(mEnt->mConnInfo, callbacks, mCaps);
       }
 
+      MOZ_LOG(mylogger, LogLevel::Info, 
+            ("f=nsHttpConnectionMgr::nsHalfOpenSocket::SetupConn called DispatchAbstractTransaction\tout=%p\ttrans=%p\tconn=%p\tconn.get=%p", out, trans, conn));
+
       gHttpHandler->ConnMgr()->AddActiveConn(conn, mEnt);
       rv = gHttpHandler->ConnMgr()->DispatchAbstractTransaction(mEnt, trans,
                                                                 mCaps, conn, 0);
@@ -4986,6 +5472,24 @@ already_AddRefed<nsHttpConnection> ConnectionHandle::HttpConnection() {
   return rv.forget();
 }
 
+uint32_t
+ConnectionHandle::CancelPipeline(nsresult reason)
+{
+    // no pipeline to cancel
+    return 0;
+}
+
+nsAHttpTransaction::Classifier
+ConnectionHandle::Classification()
+{
+    if (mConn)
+        return mConn->Classification();
+
+    LOG(("ConnectionHandle::Classification this=%p "
+         "has null mConn using CLASS_SOLO default", this));
+    return nsAHttpTransaction::CLASS_SOLO;
+}
+
 void ConnectionHandle::TopLevelOuterContentWindowIdChanged(uint64_t windowId) {
   // Do nothing.
 }
@@ -4995,6 +5499,8 @@ void ConnectionHandle::TopLevelOuterContentWindowIdChanged(uint64_t windowId) {
 nsHttpConnectionMgr::nsConnectionEntry::nsConnectionEntry(
     nsHttpConnectionInfo *ci)
     : mConnInfo(ci),
+      mPipelineState(PS_GREEN), //repipeline: starts as green
+      mGreenDepth(kPipelineOpen),
       mUsingSpdy(false),
       mPreferIPv4(false),
       mPreferIPv6(false),
@@ -5009,6 +5515,8 @@ nsHttpConnectionMgr::nsConnectionEntry::nsConnectionEntry(
     mUseFastOpen = false;
   }
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsConnectionEntry::nsConnectionEntry\tthis=%p\tci=%p", this, ci->HashKey().get()));
+
   LOG(("nsConnectionEntry::nsConnectionEntry this=%p key=%s", this,
        ci->HashKey().get()));
 }
@@ -5021,6 +5529,82 @@ bool nsHttpConnectionMgr::nsConnectionEntry::AvailableForDispatchNow() {
   return gHttpHandler->ConnMgr()->GetSpdyActiveConn(this) ? true : false;
 }
 
+bool
+nsHttpConnectionMgr::nsConnectionEntry::SupportsPipelining()
+{
+    return mPipelineState != nsHttpConnectionMgr::PS_RED;
+}
+
+nsHttpConnectionMgr::PipeliningState
+nsHttpConnectionMgr::nsConnectionEntry::PipelineState()
+{
+    return mPipelineState;
+}
+
+void
+nsHttpConnectionMgr::
+nsConnectionEntry::OnPipelineFeedbackInfo(
+    nsHttpConnectionMgr::PipelineFeedbackInfoType info,
+    nsHttpConnection *conn,
+    uint32_t data)
+{  
+    MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+
+    //repipeline: we completely ignore all pipeline feedback info and stick to PS_GREEN.
+    //Normally, red becomes yellow here unless there is a penalty.
+    //This is hyper-aggressive.
+    mPipelineState = PS_GREEN;    
+
+        switch (info) {
+        case RedVersionTooLow:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports RedVersionTooLow\tconn=%p\tent=%p", conn, this));
+            break;
+        case RedBannedServer:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports RedBannedServer\tconn=%p\tent=%p", conn, this));
+            break;
+        case RedCorruptedContent:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports RedCorruptedContent\tconn=%p\tent=%p", conn, this));
+            break;
+        case RedCanceledPipeline:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports RedCanceledPipeline\tconn=%p\tent=%p", conn, this));
+            break;
+        case BadExplicitClose:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports BadExplicitClose\tconn=%p\tent=%p", conn, this));
+            break;
+        case BadSlowReadMinor:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports BadSlowReadMinor\tconn=%p\tent=%p", conn, this));
+            break;
+        case BadSlowReadMajor:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports BadSlowReadMajor\tconn=%p\tent=%p", conn, this));
+            break;
+        case BadInsufficientFraming:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports BadInsufficientFraming\tconn=%p\tent=%p", conn, this));
+            break;
+        case BadUnexpectedLarge:
+            MOZ_LOG(mylogger, LogLevel::Debug, ("f=OnPipelineFeedbackInfo reports BadUnexpectedLarge\tconn=%p\tent=%p", conn, this));
+            break;
+        default:
+            MOZ_ASSERT(false, "Unknown Bad/Red Pipeline Feedback Event");
+        }
+            
+
+
+}
+
+uint32_t
+nsHttpConnectionMgr::
+nsConnectionEntry::MaxPipelineDepth(nsAHttpTransaction::Classifier aClass)
+{
+    // Still subject to configuration limit no matter return value
+
+    if ((mPipelineState == PS_RED)) //repipeline: removed credit check here
+        return 0;
+
+    //repipeline: removed yellow penalty here
+
+    return mGreenDepth;
+}
+
 bool nsHttpConnectionMgr::GetConnectionData(nsTArray<HttpRetParams> *aArg) {
   for (auto iter = mCT.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<nsConnectionEntry> ent = iter.Data();
@@ -5110,6 +5694,8 @@ void nsHttpConnectionMgr::nsConnectionEntry::RemoveHalfOpen(
     // perhaps this reverted RestrictConnections()
     // use the PostEvent version of processpendingq to avoid
     // altering the pending q vector from an arbitrary stack
+    MOZ_LOG(mylogger, LogLevel::Info, 
+            ("f=nsHttpConnectionMgr::RemoveHalfOpen called ProcessPendingQ\tmConnInfo=%p", mConnInfo->HashKey().get()));
     nsresult rv = gHttpHandler->ConnMgr()->ProcessPendingQ(mConnInfo);
     if (NS_FAILED(rv)) {
       LOG(
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 646740e..11395c54 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -59,6 +59,8 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
     MAX_PERSISTENT_CONNECTIONS_PER_HOST,
     MAX_PERSISTENT_CONNECTIONS_PER_PROXY,
     MAX_REQUEST_DELAY,
+    MAX_PIPELINED_REQUESTS,
+    MAX_OPTIMISTIC_PIPELINED_REQUESTS,
     THROTTLING_ENABLED,
     THROTTLING_SUSPEND_FOR,
     THROTTLING_RESUME_FOR,
@@ -78,6 +80,7 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
   Init(uint16_t maxUrgentExcessiveConns, uint16_t maxConnections,
        uint16_t maxPersistentConnectionsPerHost,
        uint16_t maxPersistentConnectionsPerProxy, uint16_t maxRequestDelay,
+       uint16_t maxPipelinedRequests, uint16_t maxOptimisticPipelinedRequests, uint32_t PipeliningPolicy,
        bool throttleEnabled, uint32_t throttleVersion,
        uint32_t throttleSuspendFor, uint32_t throttleResumeFor,
        uint32_t throttleReadLimit, uint32_t throttleReadInterval,
@@ -175,6 +178,71 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
   // clears the connection history mCT
   MOZ_MUST_USE nsresult ClearConnectionHistory();
 
+    // Pipielining Interfaces and Datatypes
+
+    const static uint32_t kPipelineInfoTypeMask = 0xffff0000;
+    const static uint32_t kPipelineInfoIDMask   = ~kPipelineInfoTypeMask;
+
+    const static uint32_t kPipelineInfoTypeRed     = 0x00010000;
+    const static uint32_t kPipelineInfoTypeBad     = 0x00020000;
+    const static uint32_t kPipelineInfoTypeNeutral = 0x00040000;
+    const static uint32_t kPipelineInfoTypeGood    = 0x00080000;
+    
+    //repipeline: A lot of those are probably unused now...
+    enum PipelineFeedbackInfoType
+    {
+        // Used when an HTTP response less than 1.1 is received
+        RedVersionTooLow = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0001,
+
+        // Used when a HTTP Server response header that is on the banned from
+        // pipelining list is received
+        RedBannedServer = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0002,
+
+        // Used when a response is terminated early, when it fails an
+        // integrity check such as assoc-req or when a 304 contained a Last-Modified
+        // differnet than the entry being validated.
+        RedCorruptedContent = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0004,
+
+        // Used when a pipeline is only partly satisfied - for instance if the
+        // server closed the connection after responding to the first
+        // request but left some requests unprocessed.
+        RedCanceledPipeline = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0005,
+
+        // Used when a connection that we expected to stay persistently open
+        // was closed by the server. Not used when simply timed out.
+        BadExplicitClose = kPipelineInfoTypeBad | 0x0003,
+
+        // Used when there is a gap of around 400 - 1200ms in between data being
+        // read from the server
+        BadSlowReadMinor = kPipelineInfoTypeBad | 0x0006,
+
+        // Used when there is a gap of > 1200ms in between data being
+        // read from the server
+        BadSlowReadMajor = kPipelineInfoTypeBad | 0x0007,
+
+        // Used when a response is received that is not framed with either chunked
+        // encoding or a complete content length.
+        BadInsufficientFraming = kPipelineInfoTypeBad | 0x0008,
+
+        // Used when a very large response is recevied in a potential pipelining
+        // context. Large responses cause head of line blocking.
+        BadUnexpectedLarge = kPipelineInfoTypeBad | 0x000B,
+
+        // Used when a response is received that has headers that appear to support
+        // pipelining.
+        NeutralExpectedOK = kPipelineInfoTypeNeutral | 0x0009,
+
+        // Used when a response is received successfully to a pipelined request.
+        GoodCompletedOK = kPipelineInfoTypeGood | 0x000A
+    };
+
+    // called to provide information relevant to the pipelining manager
+    // may be called from any thread
+    void     PipelineFeedbackInfo(nsHttpConnectionInfo *,
+                                  PipelineFeedbackInfoType info,
+                                  nsHttpConnection *,
+                                  uint32_t);
+
   void ReportFailedToProcess(nsIURI *uri);
 
   // Causes a large amount of connection diagnostic information to be
@@ -210,6 +278,8 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
   // bit different.
   void ReportSpdyConnection(nsHttpConnection *, bool usingSpdy);
 
+    bool     SupportsPipelining(nsHttpConnectionInfo *);
+
   bool GetConnectionData(nsTArray<HttpRetParams> *);
 
   void ResetIPFamilyPreference(nsHttpConnectionInfo *);
@@ -253,6 +323,13 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
  private:
   virtual ~nsHttpConnectionMgr();
 
+    enum PipeliningState {
+        //repipeline: Pipleining allowed
+        PS_GREEN,
+        //repipeline: Pipelining (temporarily) not allowed due to bad events
+        PS_RED
+    };
+
   class nsHalfOpenSocket;
   class PendingTransactionInfo;
 
@@ -300,6 +377,28 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
     // Remove a particular half open socket from the mHalfOpens array
     void RemoveHalfOpen(nsHalfOpenSocket *);
 
+    //repipeline
+
+    // Pipeline depths for various states
+    const static uint32_t kPipelineUnlimited  = 1024; // fully open - extended green
+    const static uint32_t kPipelineOpen       = 6;    // 6 on each conn - normal green
+    const static uint32_t kPipelineRestricted = 2;    // 2 on just 1 conn in yellow
+
+    nsHttpConnectionMgr::PipeliningState PipelineState();
+    void OnPipelineFeedbackInfo(
+        nsHttpConnectionMgr::PipelineFeedbackInfoType info,
+        nsHttpConnection *, uint32_t);
+    bool SupportsPipelining();
+    uint32_t MaxPipelineDepth(nsAHttpTransaction::Classifier classification);
+
+    nsHttpConnectionMgr::PipeliningState mPipelineState;
+
+    // greenDepth is the current max allowed depth of a pipeline when
+    // in the green state. Normally this starts as kPipelineOpen and
+    // grows to kPipelineUnlimited after a pipeline of depth 3 has been
+    // successfully transacted.
+    uint32_t                  mGreenDepth;
+
     // Spdy sometimes resolves the address in the socket manager in order
     // to re-coalesce sharded HTTP hosts. The dotted decimal address is
     // combined with the Anonymous flag and OA from the connection information
@@ -540,6 +639,9 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
   uint16_t mMaxPersistConnsPerHost;
   uint16_t mMaxPersistConnsPerProxy;
   uint16_t mMaxRequestDelay;  // in seconds
+  uint16_t mMaxPipelinedRequests;
+  uint16_t mMaxOptimisticPipelinedRequests;
+  uint32_t mPipeliningPolicy;
   bool mThrottleEnabled;
   uint32_t mThrottleVersion;
   uint32_t mThrottleSuspendFor;
@@ -594,6 +696,10 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
                                                     uint32_t,
                                                     nsHttpConnection *,
                                                     int32_t);
+    nsresult BuildPipeline(nsConnectionEntry *,
+                           nsAHttpTransaction *,
+                           nsHttpPipeline **);
+    bool     HasPipelines(nsConnectionEntry *);
   bool RestrictConnections(nsConnectionEntry *);
   MOZ_MUST_USE nsresult ProcessNewTransaction(nsHttpTransaction *);
   MOZ_MUST_USE nsresult EnsureSocketThreadTarget();
@@ -623,6 +729,10 @@ class nsHttpConnectionMgr final : public nsIObserver, public AltSvcCache {
 
   MOZ_MUST_USE nsresult MakeNewConnection(
       nsConnectionEntry *ent, PendingTransactionInfo *pendingTransInfo);
+  bool     AddToBestPipeline(nsConnectionEntry *ent,
+                                   nsHttpTransaction *trans,
+                                   nsHttpTransaction::Classifier classification,
+                                   uint16_t depthLimit);
 
   // Manage h2 connection coalescing
   // The hashtable contains arrays of weak pointers to nsHttpConnections
diff --git a/netwerk/protocol/http/nsHttpHandler.cpp b/netwerk/protocol/http/nsHttpHandler.cpp
index 6a58e92..89f6b21 100644
--- a/netwerk/protocol/http/nsHttpHandler.cpp
+++ b/netwerk/protocol/http/nsHttpHandler.cpp
@@ -197,6 +197,16 @@ nsHttpHandler::nsHttpHandler()
       mReferrerXOriginTrimmingPolicy(0),
       mReferrerXOriginPolicy(0),
       mFastFallbackToIPv4(false),
+      mProxyPipelining(true),
+      mPipeliningEnabled(false),
+      mMaxPipelinedRequests(32),
+      mMaxOptimisticPipelinedRequests(4),
+      mPipelineAggressive(false),
+      mMaxPipelineObjectSize(300000),
+      mPipelineRescheduleOnTimeout(true),
+      mPipelineRescheduleTimeout(PR_MillisecondsToInterval(1500)),
+      mPipelineReadTimeout(PR_MillisecondsToInterval(30000)),
+      mPipeliningOverSSL(false),
       mIdleTimeout(PR_SecondsToInterval(10)),
       mSpdyTimeout(PR_SecondsToInterval(180)),
       mResponseTimeout(PR_SecondsToInterval(300)),
@@ -604,7 +614,9 @@ nsresult nsHttpHandler::InitConnectionMgr() {
   rv = mConnMgr->Init(
       mMaxUrgentExcessiveConns, mMaxConnections,
       mMaxPersistentConnectionsPerServer, mMaxPersistentConnectionsPerProxy,
-      mMaxRequestDelay, mThrottleEnabled, mThrottleVersion, mThrottleSuspendFor,
+      mMaxRequestDelay, 
+      mMaxPipelinedRequests, mMaxOptimisticPipelinedRequests, mPipeliningPolicy,
+      mThrottleEnabled, mThrottleVersion, mThrottleSuspendFor,
       mThrottleResumeFor, mThrottleReadLimit, mThrottleReadInterval,
       mThrottleHoldTime, mThrottleMaxTime);
   return rv;
@@ -1355,6 +1367,103 @@ void nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref) {
     }
   }
 
+    //repipeline
+    if (PREF_CHANGED(HTTP_PREF("pipelining"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("pipelining"), &cVar);
+        if (NS_SUCCEEDED(rv)) {
+            if (cVar)
+                mCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
+            else
+                mCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
+            mPipeliningEnabled = cVar;
+        }
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.maxrequests"))) {
+        rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxrequests"), &val);
+        if (NS_SUCCEEDED(rv)) {
+            mMaxPipelinedRequests = clamped(val, 1, 0xffff);
+            if (mConnMgr)
+                mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PIPELINED_REQUESTS,
+                                      mMaxPipelinedRequests);
+        }
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.max-optimistic-requests"))) {
+        rv = prefs->
+            GetIntPref(HTTP_PREF("pipelining.max-optimistic-requests"), &val);
+        if (NS_SUCCEEDED(rv)) {
+            mMaxOptimisticPipelinedRequests = clamped(val, 1, 0xffff);
+            if (mConnMgr)
+                mConnMgr->UpdateParam
+                    (nsHttpConnectionMgr::MAX_OPTIMISTIC_PIPELINED_REQUESTS,
+                     mMaxOptimisticPipelinedRequests);
+        }
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.aggressive"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("pipelining.aggressive"), &cVar);
+        if (NS_SUCCEEDED(rv))
+            mPipelineAggressive = cVar;
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.maxsize"))) {
+        rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxsize"), &val);
+        if (NS_SUCCEEDED(rv)) {
+            mMaxPipelineObjectSize =
+                static_cast<int64_t>(clamped(val, 1000, 100000000));
+        }
+    }
+
+    // Determines whether or not to actually reschedule after the
+    // reschedule-timeout has expired
+    if (PREF_CHANGED(HTTP_PREF("pipelining.reschedule-on-timeout"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("pipelining.reschedule-on-timeout"),
+                                &cVar);
+        if (NS_SUCCEEDED(rv))
+            mPipelineRescheduleOnTimeout = cVar;
+    }
+
+    // The amount of time head of line blocking is allowed (in ms)
+    // before the blocked transactions are moved to another pipeline
+    if (PREF_CHANGED(HTTP_PREF("pipelining.reschedule-timeout"))) {
+        rv = prefs->GetIntPref(HTTP_PREF("pipelining.reschedule-timeout"),
+                               &val);
+        if (NS_SUCCEEDED(rv)) {
+            mPipelineRescheduleTimeout =
+                PR_MillisecondsToInterval((uint16_t) clamped(val, 500, 0xffff));
+        }
+    }
+
+    // The amount of time a pipelined transaction is allowed to wait before
+    // being canceled and retried in a non-pipeline connection
+    if (PREF_CHANGED(HTTP_PREF("pipelining.read-timeout"))) {
+        rv = prefs->GetIntPref(HTTP_PREF("pipelining.read-timeout"), &val);
+        if (NS_SUCCEEDED(rv)) {
+            mPipelineReadTimeout =
+                PR_MillisecondsToInterval((uint16_t) clamped(val, 5000,
+                                                             0xffff));
+        }
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.ssl"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("pipelining.ssl"), &cVar);
+        if (NS_SUCCEEDED(rv))
+            mPipeliningOverSSL = cVar;
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("proxy.pipelining"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("proxy.pipelining"), &cVar);
+        if (NS_SUCCEEDED(rv))
+            mProxyPipelining = cVar;
+    }
+
+    if (PREF_CHANGED(HTTP_PREF("pipelining.policy"))) {
+        rv = prefs->GetBoolPref(HTTP_PREF("pipelining.policy"), &cVar);
+        if (NS_SUCCEEDED(rv))
+            mPipeliningPolicy = cVar;
+    }
+
   if (PREF_CHANGED(HTTP_PREF("qos"))) {
     rv = prefs->GetIntPref(HTTP_PREF("qos"), &val);
     if (NS_SUCCEEDED(rv)) mQoSBits = (uint8_t)clamped(val, 0, 0xff);
@@ -2101,6 +2210,12 @@ nsHttpHandler::NewProxiedChannel2(nsIURI *uri, nsIProxyInfo *givenProxyInfo,
 
   uint32_t caps = mCapabilities;
 
+    if (https) {
+        // enable pipelining over SSL if requested
+        if (mPipeliningOverSSL)
+            caps |= NS_HTTP_ALLOW_PIPELINING;
+    }
+
   if (!IsNeckoChild()) {
     // HACK: make sure PSM gets initialized on the main thread.
     net_EnsurePSMInit();
diff --git a/netwerk/protocol/http/nsHttpHandler.h b/netwerk/protocol/http/nsHttpHandler.h
index 57a09a4..2ec4cec 100644
--- a/netwerk/protocol/http/nsHttpHandler.h
+++ b/netwerk/protocol/http/nsHttpHandler.h
@@ -98,6 +98,7 @@ class nsHttpHandler final : public nsIHttpProtocolHandler,
   uint8_t GetQoSBits() { return mQoSBits; }
   uint16_t GetIdleSynTimeout() { return mIdleSynTimeout; }
   bool FastFallbackToIPv4() { return mFastFallbackToIPv4; }
+  bool ProxyPipelining() { return mProxyPipelining; }
   uint32_t MaxSocketCount();
   bool EnforceAssocReq() { return mEnforceAssocReq; }
 
@@ -362,6 +363,32 @@ class nsHttpHandler final : public nsIHttpProtocolHandler,
                                                 int32_t port,
                                                 nsACString &hostLine);
 
+    bool GetPipelineAggressive()     { return mPipelineAggressive; }
+    uint32_t GetMaxPipelinedRequests()     { return mMaxPipelinedRequests; }
+    uint32_t GetMaxOptimisticPipelinedRequests()     { return mMaxOptimisticPipelinedRequests; }
+    uint32_t GetPipeliningPolicy() { return mPipeliningPolicy; }
+    void GetMaxPipelineObjectSize(int64_t *outVal)
+    {
+        *outVal = mMaxPipelineObjectSize;
+    }
+
+    bool GetPipelineEnabled()
+    {
+        return mCapabilities & NS_HTTP_ALLOW_PIPELINING;
+    }
+
+    bool GetPipelineRescheduleOnTimeout()
+    {
+        return mPipelineRescheduleOnTimeout;
+    }
+
+    PRIntervalTime GetPipelineRescheduleTimeout()
+    {
+        return mPipelineRescheduleTimeout;
+    }
+
+    PRIntervalTime GetPipelineTimeout()   { return mPipelineReadTimeout; }
+
   SpdyInformation *SpdyInfo() { return &mSpdyInfo; }
   bool IsH2MandatorySuiteEnabled() { return mH2MandatorySuiteEnabled; }
 
@@ -449,6 +476,7 @@ class nsHttpHandler final : public nsIHttpProtocolHandler,
   uint8_t mReferrerXOriginPolicy;
 
   bool mFastFallbackToIPv4;
+  bool mProxyPipelining;
   PRIntervalTime mIdleTimeout;
   PRIntervalTime mSpdyTimeout;
   PRIntervalTime mResponseTimeout;
@@ -459,10 +487,20 @@ class nsHttpHandler final : public nsIHttpProtocolHandler,
   uint16_t mIdleSynTimeout;
 
   bool mH2MandatorySuiteEnabled;
+  bool     mPipeliningEnabled;
   uint16_t mMaxUrgentExcessiveConns;
   uint16_t mMaxConnections;
   uint8_t mMaxPersistentConnectionsPerServer;
   uint8_t mMaxPersistentConnectionsPerProxy;
+  uint16_t mMaxPipelinedRequests;
+  uint16_t mMaxOptimisticPipelinedRequests;
+  bool     mPipelineAggressive;
+  int64_t  mMaxPipelineObjectSize;
+  bool     mPipelineRescheduleOnTimeout;
+  PRIntervalTime mPipelineRescheduleTimeout;
+  PRIntervalTime mPipelineReadTimeout;
+  nsCOMPtr<nsITimer> mPipelineTestTimer;
+  uint32_t mPipeliningPolicy;
 
   bool mThrottleEnabled;
   uint32_t mThrottleVersion;
@@ -488,7 +526,8 @@ class nsHttpHandler final : public nsIHttpProtocolHandler,
   // the userpass field of the URL to obscure the actual origin server.
   uint8_t mPhishyUserPassLength;
 
-  uint8_t mQoSBits;
+  uint8_t mQoSBits;    
+  bool mPipeliningOverSSL;
 
   bool mEnforceAssocReq;
 
diff --git a/netwerk/protocol/http/nsHttpPipeline.cpp b/netwerk/protocol/http/nsHttpPipeline.cpp
new file mode 100644
index 0000000..ae8387c
--- /dev/null
+++ b/netwerk/protocol/http/nsHttpPipeline.cpp
@@ -0,0 +1,1001 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// HttpLog.h should generally be included first
+#include "HttpLog.h"
+
+#include "nsHttpPipeline.h"
+#include "nsHttpHandler.h"
+#include "nsIOService.h"
+#include "nsISocketTransport.h"
+#include "nsIPipe.h"
+#include "nsCOMPtr.h"
+#include "nsSocketTransportService2.h"
+#include <algorithm>
+#include "nsHttpRequestHead.h"
+
+#ifdef WTF_TEST
+#include <inttypes.h>
+#endif
+
+#ifdef DEBUG
+#include "prthread.h"
+#endif
+
+namespace mozilla {
+namespace net {
+
+//-----------------------------------------------------------------------------
+// nsHttpPushBackWriter
+//-----------------------------------------------------------------------------
+
+class nsHttpPushBackWriter : public nsAHttpSegmentWriter
+{
+public:
+    nsHttpPushBackWriter(const char *buf, uint32_t bufLen)
+        : mBuf(buf)
+        , mBufLen(bufLen)
+        { }
+    virtual ~nsHttpPushBackWriter() {}
+
+    nsresult OnWriteSegment(char *buf, uint32_t count, uint32_t *countWritten)
+    {
+        if (mBufLen == 0)
+            return NS_BASE_STREAM_CLOSED;
+
+        if (count > mBufLen)
+            count = mBufLen;
+
+        memcpy(buf, mBuf, count);
+
+        mBuf += count;
+        mBufLen -= count;
+        *countWritten = count;
+        return NS_OK;
+    }
+
+private:
+    const char *mBuf;
+    uint32_t    mBufLen;
+};
+
+//-----------------------------------------------------------------------------
+// nsHttpPipeline <public>
+//-----------------------------------------------------------------------------
+
+nsHttpPipeline::nsHttpPipeline()
+    : mStatus(NS_OK)
+    , mRequestIsPartial(false)
+    , mResponseIsPartial(false)
+    , mClosed(false)
+    , mUtilizedPipeline(false)
+    , mPushBackBuf(nullptr)
+    , mPushBackLen(0)
+    , mPushBackMax(0)
+    , mHttp1xTransactionCount(0)
+    , mReceivingFromProgress(0)
+    , mSendingToProgress(0)
+    , mSuppressSendEvents(true)
+{
+}
+
+nsHttpPipeline::~nsHttpPipeline()
+{
+    // make sure we aren't still holding onto any transactions!
+    Close(NS_ERROR_ABORT);
+
+    if (mPushBackBuf)
+        free(mPushBackBuf);
+}
+
+// Generate a shuffled request ordering sequence
+void
+nsHttpPipeline::ShuffleTransOrder(uint32_t count)
+{
+   if (count < 2)
+       return;
+
+   uint32_t pos = mRequestQ[0]->PipelinePosition();
+   uint32_t i = 0;
+
+   for (i=0; i < count; ++i) {
+       uint32_t ridx = rand() % count;
+
+       nsAHttpTransaction *tmp = mRequestQ[i];
+       mRequestQ[i] = mRequestQ[ridx];
+       mRequestQ[ridx] = tmp;
+   }
+
+   for (i=0; i < count; ++i) {
+       mRequestQ[i]->SetPipelinePosition(pos);
+       pos++;
+   }
+
+   LOG(("nsHttpPipeline::ShuffleTransOrder: Shuffled %d transactions.\n", count));
+}
+
+nsresult
+nsHttpPipeline::AddTransaction(nsAHttpTransaction *trans)
+{
+    LOG(("nsHttpPipeline::AddTransaction [this=%p trans=%p]\n", this, trans));
+
+    if (mRequestQ.Length() || mResponseQ.Length())
+        mUtilizedPipeline = true;
+
+    // A reference to the actual transaction is held by the pipeline transaction
+    // in either the request or response queue
+    mRequestQ.AppendElement(trans);
+    uint32_t qlen = PipelineDepth();
+
+    if (qlen != 1) {
+        trans->SetPipelinePosition(qlen);
+    }
+    else {
+        // do it for this case in case an idempotent cancellation
+        // is being repeated and an old value needs to be cleared
+        trans->SetPipelinePosition(0);
+    }
+
+    // trans->SetConnection() needs to be updated to point back at
+    // the pipeline object.
+    trans->SetConnection(this);
+
+    //ShuffleTransOrder(mRequestQ.Length()); //repipeline: let's not do this.
+
+    if (mConnection && !mClosed && mRequestQ.Length() == 1)
+        mConnection->ResumeSend();
+
+    return NS_OK;
+}
+
+uint32_t
+nsHttpPipeline::PipelineDepth()
+{
+    return mRequestQ.Length() + mResponseQ.Length();
+}
+
+nsresult
+nsHttpPipeline::SetPipelinePosition(int32_t position)
+{
+    nsAHttpTransaction *trans = Response(0);
+    if (trans)
+        return trans->SetPipelinePosition(position);
+    return NS_OK;
+}
+
+int32_t
+nsHttpPipeline::PipelinePosition()
+{
+    nsAHttpTransaction *trans = Response(0);
+    if (trans)
+        return trans->PipelinePosition();
+
+    // The response queue is empty, so return oldest request
+    if (mRequestQ.Length())
+        return Request(mRequestQ.Length() - 1)->PipelinePosition();
+
+    // No transactions in the pipeline
+    return 0;
+}
+
+nsHttpPipeline *
+nsHttpPipeline::QueryPipeline()
+{
+    return this;
+}
+
+//-----------------------------------------------------------------------------
+// nsHttpPipeline::nsISupports
+//-----------------------------------------------------------------------------
+
+NS_IMPL_ADDREF(nsHttpPipeline)
+NS_IMPL_RELEASE(nsHttpPipeline)
+
+// multiple inheritance fun :-)
+NS_INTERFACE_MAP_BEGIN(nsHttpPipeline)
+    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsAHttpConnection)
+NS_INTERFACE_MAP_END
+
+
+//-----------------------------------------------------------------------------
+// nsHttpPipeline::nsAHttpConnection
+//-----------------------------------------------------------------------------
+
+nsresult
+nsHttpPipeline::OnHeadersAvailable(nsAHttpTransaction *trans,
+                                   nsHttpRequestHead *requestHead,
+                                   nsHttpResponseHead *responseHead,
+                                   bool *reset)
+{
+    LOG(("nsHttpPipeline::OnHeadersAvailable [this=%p]\n", this));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+    MOZ_ASSERT(mConnection, "no connection");
+
+    RefPtr<nsHttpConnectionInfo> ci;
+    GetConnectionInfo(getter_AddRefs(ci));
+    MOZ_ASSERT(ci);
+
+    if (!ci) {
+        return NS_ERROR_UNEXPECTED;
+    }
+
+    bool pipeliningBefore = gHttpHandler->ConnMgr()->SupportsPipelining(ci);
+
+    // trans has now received its response headers; forward to the real connection
+    nsresult rv = mConnection->OnHeadersAvailable(trans,
+                                                  requestHead,
+                                                  responseHead,
+                                                  reset);
+
+    if (!pipeliningBefore && gHttpHandler->ConnMgr()->SupportsPipelining(ci)) {
+        // The received headers have expanded the eligible
+        // pipeline depth for this connection
+        gHttpHandler->ConnMgr()->ProcessPendingQForEntry(ci);
+    }
+
+    return rv;
+}
+
+void
+nsHttpPipeline::CloseTransaction(nsAHttpTransaction *aTrans, nsresult reason)
+{
+    LOG(("nsHttpPipeline::CloseTransaction [this=%p trans=%p reason=%x]\n",
+        this, aTrans, reason));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+    MOZ_ASSERT(NS_FAILED(reason), "expecting failure code");
+
+    // the specified transaction is to be closed with the given "reason"
+    RefPtr<nsAHttpTransaction> trans(aTrans);
+    int32_t index;
+    bool killPipeline = false;
+
+    if ((index = mRequestQ.IndexOf(trans)) >= 0) {
+        if (index == 0 && mRequestIsPartial) {
+            // the transaction is in the request queue.  check to see if any of
+            // its data has been written out yet.
+            killPipeline = true;
+        }
+        mRequestQ.RemoveElementAt(index);
+    } else if ((index = mResponseQ.IndexOf(trans)) >= 0) {
+        mResponseQ.RemoveElementAt(index);
+        // while we could avoid killing the pipeline if this transaction is the
+        // last transaction in the pipeline, there doesn't seem to be that much
+        // value in doing so.  most likely if this transaction is going away,
+        // the others will be shortly as well.
+        killPipeline = true;
+    }
+
+    // Marking this connection as non-reusable prevents other items from being
+    // added to it and causes it to be torn down soon.
+    DontReuse();
+
+    trans->Close(reason);
+    trans = nullptr;
+
+    if (killPipeline) {
+        // reschedule anything from this pipeline onto a different connection
+        CancelPipeline(reason);
+    }
+
+    // If all the transactions have been removed then we can close the connection
+    // right away.
+    if (!mRequestQ.Length() && !mResponseQ.Length() && mConnection)
+        mConnection->CloseTransaction(this, reason);
+}
+
+nsresult
+nsHttpPipeline::TakeTransport(nsISocketTransport  **aTransport,
+                              nsIAsyncInputStream **aInputStream,
+                              nsIAsyncOutputStream **aOutputStream)
+{
+    return mConnection->TakeTransport(aTransport, aInputStream, aOutputStream);
+}
+
+bool
+nsHttpPipeline::IsPersistent()
+{
+    return true; // pipelining requires this
+}
+
+bool
+nsHttpPipeline::IsReused()
+{
+    if (!mUtilizedPipeline && mConnection)
+        return mConnection->IsReused();
+    return true;
+}
+
+void
+nsHttpPipeline::DontReuse()
+{
+    if (mConnection)
+        mConnection->DontReuse();
+}
+
+nsresult
+nsHttpPipeline::PushBack(const char *data, uint32_t length)
+{
+    LOG(("nsHttpPipeline::PushBack [this=%p len=%u]\n", this, length));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+    MOZ_ASSERT(mPushBackLen == 0, "push back buffer already has data!");
+
+    // If we have no chance for a pipeline (e.g. due to an Upgrade)
+    // then push this data down to original connection
+    if (!mConnection->IsPersistent())
+        return mConnection->PushBack(data, length);
+
+    // PushBack is called recursively from WriteSegments
+
+    // XXX we have a design decision to make here.  either we buffer the data
+    // and process it when we return to WriteSegments, or we attempt to move
+    // onto the next transaction from here.  doing so adds complexity with the
+    // benefit of eliminating the extra buffer copy.  the buffer is at most
+    // 4096 bytes, so it is really unclear if there is any value in the added
+    // complexity.  besides simplicity, buffering this data has the advantage
+    // that we'll call close on the transaction sooner, which will wake up
+    // the HTTP channel sooner to continue with its work.
+
+    if (!mPushBackBuf) {
+        mPushBackMax = length;
+        mPushBackBuf = (char *) malloc(mPushBackMax);
+        if (!mPushBackBuf)
+            return NS_ERROR_OUT_OF_MEMORY;
+    }
+    else if (length > mPushBackMax) {
+        // grow push back buffer as necessary.
+        MOZ_ASSERT(length <= nsIOService::gDefaultSegmentSize, "too big");
+        mPushBackMax = length;
+        mPushBackBuf = (char *) realloc(mPushBackBuf, mPushBackMax);
+        if (!mPushBackBuf)
+            return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    memcpy(mPushBackBuf, data, length);
+    mPushBackLen = length;
+
+    return NS_OK;
+}
+
+already_AddRefed<nsHttpConnection>
+nsHttpPipeline::TakeHttpConnection()
+{
+    if (mConnection)
+        return mConnection->TakeHttpConnection();
+    return nullptr;
+}
+
+nsAHttpTransaction::Classifier
+nsHttpPipeline::Classification()
+{
+    if (mConnection)
+        return mConnection->Classification();
+
+    LOG(("nsHttpPipeline::Classification this=%p "
+         "has null mConnection using CLASS_SOLO default", this));
+    return nsAHttpTransaction::CLASS_SOLO;
+}
+
+void
+nsHttpPipeline::SetProxyConnectFailed()
+{
+    nsAHttpTransaction *trans = Request(0);
+
+    if (trans)
+        trans->SetProxyConnectFailed();
+}
+
+nsHttpRequestHead *
+nsHttpPipeline::RequestHead()
+{
+    nsAHttpTransaction *trans = Request(0);
+
+    if (trans)
+        return trans->RequestHead();
+    return nullptr;
+}
+
+uint32_t
+nsHttpPipeline::Http1xTransactionCount()
+{
+  return mHttp1xTransactionCount;
+}
+
+nsresult
+nsHttpPipeline::TakeSubTransactions(
+    nsTArray<RefPtr<nsAHttpTransaction> > &outTransactions)
+{
+    LOG(("nsHttpPipeline::TakeSubTransactions [this=%p]\n", this));
+
+    if (mResponseQ.Length() || mRequestIsPartial)
+        return NS_ERROR_ALREADY_OPENED;
+
+    int32_t i, count = mRequestQ.Length();
+    for (i = 0; i < count; ++i) {
+        nsAHttpTransaction *trans = Request(i);
+        // set the transaction connection object back to the underlying
+        // nsHttpConnectionHandle
+        trans->SetConnection(mConnection);
+        outTransactions.AppendElement(trans);
+    }
+    mRequestQ.Clear();
+
+    LOG(("   took %d\n", count));
+    return NS_OK;
+}
+
+//-----------------------------------------------------------------------------
+// nsHttpPipeline::nsAHttpTransaction
+//-----------------------------------------------------------------------------
+
+void
+nsHttpPipeline::SetConnection(nsAHttpConnection *conn)
+{
+    LOG(("nsHttpPipeline::SetConnection [this=%p conn=%p]\n", this, conn));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+    MOZ_ASSERT(!conn || !mConnection, "already have a connection");
+
+    mConnection = conn;
+}
+
+nsAHttpConnection *
+nsHttpPipeline::Connection()
+{
+    LOG(("nsHttpPipeline::Connection [this=%p conn=%p]\n", this, mConnection.get()));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+    return mConnection;
+}
+
+//repipeline: Added this function because it's a pure virtual that needs to be overriden
+already_AddRefed<nsHttpConnection> nsHttpPipeline::HttpConnection() {
+  if (mConnection) {
+    return mConnection->HttpConnection();
+  }
+  return nullptr;
+}
+
+void
+nsHttpPipeline::GetSecurityCallbacks(nsIInterfaceRequestor **result)
+{
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+
+    // depending on timing this could be either the request or the response
+    // that is needed - but they both go to the same host. A request for these
+    // callbacks directly in nsHttpTransaction would not make a distinction
+    // over whether the the request had been transmitted yet.
+    nsAHttpTransaction *trans = Request(0);
+    if (!trans)
+        trans = Response(0);
+    if (trans)
+        trans->GetSecurityCallbacks(result);
+    else {
+        *result = nullptr;
+    }
+}
+
+void
+nsHttpPipeline::OnTransportStatus(nsITransport* transport,
+                                  nsresult status, int64_t progress)
+{
+    LOG(("nsHttpPipeline::OnStatus [this=%p status=%x progress=%lld]\n",
+        this, status, progress));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+
+    nsAHttpTransaction *trans;
+    int32_t i, count;
+
+    switch (status) {
+
+    case NS_NET_STATUS_RESOLVING_HOST:
+    case NS_NET_STATUS_RESOLVED_HOST:
+    case NS_NET_STATUS_CONNECTING_TO:
+    case NS_NET_STATUS_CONNECTED_TO:
+        // These should only appear at most once per pipeline.
+        // Deliver to the first transaction.
+
+        trans = Request(0);
+        if (!trans)
+            trans = Response(0);
+        if (trans)
+            trans->OnTransportStatus(transport, status, progress);
+
+        break;
+
+    case NS_NET_STATUS_SENDING_TO:
+        // This is generated by the socket transport when (part) of
+        // a transaction is written out
+        //
+        // In pipelining this is generated out of FillSendBuf(), but it cannot do
+        // so until the connection is confirmed by CONNECTED_TO.
+        // See patch for bug 196827.
+        //
+
+        if (mSuppressSendEvents) {
+            mSuppressSendEvents = false;
+
+            // catch up by sending the event to all the transactions that have
+            // moved from request to response and any that have been partially
+            // sent. Also send WAITING_FOR to those that were completely sent
+            count = mResponseQ.Length();
+            for (i = 0; i < count; ++i) {
+                Response(i)->OnTransportStatus(transport,
+                                               NS_NET_STATUS_SENDING_TO,
+                                               progress);
+                Response(i)->OnTransportStatus(transport,
+                                               NS_NET_STATUS_WAITING_FOR,
+                                               progress);
+            }
+            if (mRequestIsPartial && Request(0))
+                Request(0)->OnTransportStatus(transport,
+                                              NS_NET_STATUS_SENDING_TO,
+                                              progress);
+            mSendingToProgress = progress;
+        }
+        // otherwise ignore it
+        break;
+
+    case NS_NET_STATUS_WAITING_FOR:
+        // Created by nsHttpConnection when request pipeline has been totally
+        // sent. Ignore it here because it is simulated in FillSendBuf() when
+        // a request is moved from request to response.
+
+        // ignore it
+        break;
+
+    case NS_NET_STATUS_RECEIVING_FROM:
+        // Forward this only to the transaction currently recieving data. It is
+        // normally generated by the socket transport, but can also
+        // be repeated by the pushbackwriter if necessary.
+        mReceivingFromProgress = progress;
+        if (Response(0))
+            Response(0)->OnTransportStatus(transport, status, progress);
+        break;
+
+    default:
+        // forward other notifications to all request transactions
+        count = mRequestQ.Length();
+        for (i = 0; i < count; ++i)
+            Request(i)->OnTransportStatus(transport, status, progress);
+        break;
+    }
+}
+
+nsHttpConnectionInfo *
+nsHttpPipeline::ConnectionInfo()
+{
+    nsAHttpTransaction *trans = Request(0) ? Request(0) : Response(0);
+    if (!trans) {
+        return nullptr;
+    }
+    return trans->ConnectionInfo();
+}
+
+bool
+nsHttpPipeline::IsDone()
+{
+    bool done = true;
+
+    uint32_t i, count = mRequestQ.Length();
+    for (i = 0; done && (i < count); i++)
+        done = Request(i)->IsDone();
+
+    count = mResponseQ.Length();
+    for (i = 0; done && (i < count); i++)
+        done = Response(i)->IsDone();
+
+    return done;
+}
+
+nsresult
+nsHttpPipeline::Status()
+{
+    return mStatus;
+}
+
+uint32_t
+nsHttpPipeline::Caps()
+{
+    nsAHttpTransaction *trans = Request(0);
+    if (!trans)
+        trans = Response(0);
+
+    return trans ? trans->Caps() : 0;
+}
+
+void
+nsHttpPipeline::SetDNSWasRefreshed()
+{
+    nsAHttpTransaction *trans = Request(0);
+    if (!trans)
+        trans = Response(0);
+
+    if (trans)
+      trans->SetDNSWasRefreshed();
+}
+
+uint64_t
+nsHttpPipeline::Available()
+{
+    uint64_t result = 0;
+
+    int32_t i, count = mRequestQ.Length();
+    for (i=0; i<count; ++i)
+        result += Request(i)->Available();
+    return result;
+}
+
+nsresult
+nsHttpPipeline::ReadFromPipe(nsIInputStream *stream,
+                             void *closure,
+                             const char *buf,
+                             uint32_t offset,
+                             uint32_t count,
+                             uint32_t *countRead)
+{
+    nsHttpPipeline *self = (nsHttpPipeline *) closure;
+    return self->mReader->OnReadSegment(buf, count, countRead);
+}
+
+nsresult
+nsHttpPipeline::ReadSegments(nsAHttpSegmentReader *reader,
+                             uint32_t count,
+                             uint32_t *countRead)
+{
+    LOG(("nsHttpPipeline::ReadSegments [this=%p count=%u]\n", this, count));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+
+    if (mClosed) {
+        *countRead = 0;
+        return mStatus;
+    }
+
+    nsresult rv;
+    uint64_t avail = 0;
+    if (mSendBufIn) {
+        rv = mSendBufIn->Available(&avail);
+        if (NS_FAILED(rv)) return rv;
+    }
+
+    if (avail == 0) {
+        rv = FillSendBuf();
+        if (NS_FAILED(rv)) return rv;
+
+        rv = mSendBufIn->Available(&avail);
+        if (NS_FAILED(rv)) return rv;
+
+        // return EOF if send buffer is empty
+        if (avail == 0) {
+            *countRead = 0;
+            return NS_OK;
+        }
+    }
+
+    // read no more than what was requested
+    if (avail > count)
+        avail = count;
+
+    mReader = reader;
+
+    // avail is under 4GB, so casting to uint32_t is safe
+    rv = mSendBufIn->ReadSegments(ReadFromPipe, this, (uint32_t)avail, countRead);
+
+    mReader = nullptr;
+    return rv;
+}
+
+nsresult
+nsHttpPipeline::WriteSegments(nsAHttpSegmentWriter *writer,
+                              uint32_t count,
+                              uint32_t *countWritten)
+{
+    LOG(("nsHttpPipeline::WriteSegments [this=%p count=%u]\n", this, count));
+
+    MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
+
+    if (mClosed)
+        return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
+
+    nsAHttpTransaction *trans;
+    nsresult rv;
+
+    trans = Response(0);
+    // This code deals with the establishment of a CONNECT tunnel through
+    // an HTTP proxy. It allows the connection to do the CONNECT/200
+    // HTTP transaction to establish a tunnel as a precursor to the
+    // actual pipeline of regular HTTP transactions.
+    if (!trans && mRequestQ.Length() &&
+        mConnection->IsProxyConnectInProgress()) {
+        LOG(("nsHttpPipeline::WriteSegments [this=%p] Forced Delegation\n",
+             this));
+        trans = Request(0);
+    }
+
+    if (!trans) {
+        if (mRequestQ.Length() > 0)
+            rv = NS_BASE_STREAM_WOULD_BLOCK;
+        else
+            rv = NS_BASE_STREAM_CLOSED;
+    } else {
+        //
+        // ask the transaction to consume data from the connection.
+        // PushBack may be called recursively.
+        //
+        rv = trans->WriteSegments(writer, count, countWritten);
+
+        if (rv == NS_BASE_STREAM_CLOSED || trans->IsDone()) {
+            trans->Close(NS_OK);
+
+            // Release the transaction if it is not IsProxyConnectInProgress()
+            if (trans == Response(0)) {
+                mResponseQ.RemoveElementAt(0);
+                mResponseIsPartial = false;
+                ++mHttp1xTransactionCount;
+            }
+
+            // ask the connection manager to add additional transactions
+            // to our pipeline.
+            RefPtr<nsHttpConnectionInfo> ci;
+            GetConnectionInfo(getter_AddRefs(ci));
+            if (ci)
+                gHttpHandler->ConnMgr()->ProcessPendingQForEntry(ci);
+        }
+        else
+            mResponseIsPartial = true;
+    }
+
+    if (mPushBackLen) {
+        nsHttpPushBackWriter pushBackWriter(mPushBackBuf, mPushBackLen);
+        uint32_t len = mPushBackLen, n;
+        mPushBackLen = 0;
+
+        // This progress notification has previously been sent from
+        // the socket transport code, but it was delivered to the
+        // previous transaction on the pipeline.
+        nsITransport *transport = Transport();
+        if (transport)
+            OnTransportStatus(transport, NS_NET_STATUS_RECEIVING_FROM,
+                              mReceivingFromProgress);
+
+        // the push back buffer is never larger than NS_HTTP_SEGMENT_SIZE,
+        // so we are guaranteed that the next response will eat the entire
+        // push back buffer (even though it might again call PushBack).
+        rv = WriteSegments(&pushBackWriter, len, &n);
+    }
+
+    return rv;
+}
+
+uint32_t
+nsHttpPipeline::CancelPipeline(nsresult originalReason)
+{
+    uint32_t i, reqLen, respLen, total;
+    nsAHttpTransaction *trans;
+
+    reqLen = mRequestQ.Length();
+    respLen = mResponseQ.Length();
+    total = reqLen + respLen;
+
+    // don't count the first response, if presnet
+    if (respLen)
+        total--;
+
+    if (!total)
+        return 0;
+
+    // any pending requests can ignore this error and be restarted
+    // unless it is during a CONNECT tunnel request
+    for (i = 0; i < reqLen; ++i) {
+        trans = Request(i);
+        if (mConnection && mConnection->IsProxyConnectInProgress())
+            trans->Close(originalReason);
+        else
+            trans->Close(NS_ERROR_NET_RESET);
+    }
+    mRequestQ.Clear();
+
+    // any pending responses can be restarted except for the first one,
+    // that we might want to finish on this pipeline or cancel individually.
+    // Higher levels of callers ensure that we don't process non-idempotent
+    // tranasction with the NS_HTTP_ALLOW_PIPELINING bit set
+    for (i = 1; i < respLen; ++i) {
+        trans = Response(i);
+        trans->Close(NS_ERROR_NET_RESET);
+    }
+
+    if (respLen > 1)
+        mResponseQ.TruncateLength(1);
+
+    /* Don't flag timed out connections as unreusable.. Tor is just slow :( */
+    if (originalReason != NS_ERROR_NET_TIMEOUT) {
+        DontReuse();
+        Classify(nsAHttpTransaction::CLASS_SOLO);
+    }
+
+    return total;
+}
+
+void
+nsHttpPipeline::Close(nsresult reason)
+{
+    LOG(("nsHttpPipeline::Close [this=%p reason=%x]\n", this, reason));
+
+    if (mClosed) {
+        LOG(("  already closed\n"));
+        return;
+    }
+
+    // the connection is going away!
+    mStatus = reason;
+    mClosed = true;
+
+    RefPtr<nsHttpConnectionInfo> ci;
+    GetConnectionInfo(getter_AddRefs(ci));
+    uint32_t numRescheduled = CancelPipeline(reason);
+
+    // numRescheduled can be 0 if there is just a single response in the
+    // pipeline object. That isn't really a meaningful pipeline that
+    // has been forced to be rescheduled so it does not need to generate
+    // negative feedback.
+    if (ci && numRescheduled)
+        gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+            ci, nsHttpConnectionMgr::RedCanceledPipeline, nullptr, 0);
+
+    nsAHttpTransaction *trans = Response(0);
+    if (!trans)
+        return;
+
+    // The current transaction can be restarted via reset
+    // if the response has not started to arrive and the reason
+    // for failure is innocuous (e.g. not an SSL error)
+    if (!mResponseIsPartial &&
+        (reason == NS_ERROR_NET_RESET ||
+         reason == NS_OK ||
+         reason == NS_ERROR_NET_TIMEOUT ||
+         reason == NS_BASE_STREAM_CLOSED)) {
+        trans->Close(NS_ERROR_NET_RESET);
+    }
+    else {
+        trans->Close(reason);
+    }
+
+    mResponseQ.Clear();
+}
+
+nsresult
+nsHttpPipeline::OnReadSegment(const char *segment,
+                              uint32_t count,
+                              uint32_t *countRead)
+{
+    return mSendBufOut->Write(segment, count, countRead);
+}
+
+nsresult
+nsHttpPipeline::FillSendBuf()
+{
+    // reads from request queue, moving transactions to response queue
+    // when they have been completely read.
+
+    nsresult rv;
+
+    if (!mSendBufIn) {
+        // allocate a single-segment pipe
+        rv = NS_NewPipe(getter_AddRefs(mSendBufIn),
+                        getter_AddRefs(mSendBufOut),
+                        nsIOService::gDefaultSegmentSize,  /* segment size */
+                        nsIOService::gDefaultSegmentSize,  /* max size */
+                        true, true);
+        if (NS_FAILED(rv)) return rv;
+    }
+
+    uint32_t n;
+    uint64_t avail;
+    uint64_t totalSent = 0;
+    uint64_t reqsSent = 0;
+    uint64_t alreadyPending = 0;
+
+    mSendBufIn->Available(&alreadyPending);
+
+    RefPtr<nsAHttpTransaction> trans;
+    nsITransport *transport = Transport();
+#ifdef WTF_TEST
+    uint64_t totalAvailable = Available();
+    RefPtr<nsHttpConnectionInfo> ci;
+    GetConnectionInfo(getter_AddRefs(ci));
+#endif
+
+    while ((trans = Request(0)) != nullptr) {
+        avail = trans->Available();
+        if (avail) {
+            // if there is already a response in the responseq then this
+            // new data comprises a pipeline. Update the transaction in the
+            // response queue to reflect that if necessary. We are now sending
+            // out a request while we haven't received all responses.
+            nsAHttpTransaction *response = Response(0);
+            if (response && !response->PipelinePosition())
+                response->SetPipelinePosition(1);
+            rv = trans->ReadSegments(this, (uint32_t)std::min(avail, (uint64_t)UINT32_MAX), &n);
+            if (NS_FAILED(rv)) return rv;
+
+            if (n == 0) {
+                LOG(("send pipe is full"));
+                break;
+            }
+
+            mSendingToProgress += n;
+            totalSent += n;
+            if (!mSuppressSendEvents && transport) {
+                // Simulate a SENDING_TO event
+                trans->OnTransportStatus(transport,
+                                         NS_NET_STATUS_SENDING_TO,
+                                         mSendingToProgress);
+            }
+        }
+
+        avail = trans->Available();
+        if (avail == 0) {
+#ifdef WTF_TEST
+            nsHttpRequestHead *head = trans->RequestHead();
+			nsAutoCString requestURI;
+			if (head) {
+				head->RequestURI(requestURI);
+			} else {
+				requestURI = "<unknown?>";
+			}
+            fprintf(stderr, "WTF-order: Pipelined req %d/%d (%dB). Url: %s%s\n",
+                    trans->PipelinePosition(), PipelineDepth(), n,
+                    ci->Origin(), requestURI.get());
+#endif
+            reqsSent++;
+
+            // move transaction from request queue to response queue
+            mRequestQ.RemoveElementAt(0);
+            mResponseQ.AppendElement(trans);
+            mRequestIsPartial = false;
+
+            if (!mSuppressSendEvents && transport) {
+                // Simulate a WAITING_FOR event
+                trans->OnTransportStatus(transport,
+                                         NS_NET_STATUS_WAITING_FOR,
+                                         mSendingToProgress);
+            }
+
+            // It would be good to re-enable data read handlers via ResumeRecv()
+            // except the read handler code can be synchronously dispatched on
+            // the stack.
+        }
+        else
+            mRequestIsPartial = true;
+    }
+
+#ifdef WTF_TEST
+    if (totalSent)
+      fprintf(stderr,
+              "WTF-combine: Sent %" PRIu64 "/%" PRIu64 " bytes of %" PRIu64
+              " combined pipelined requests for host %s\n",
+              alreadyPending+totalSent, totalAvailable, reqsSent, ci->Origin());
+#endif
+
+    return NS_OK;
+}
+
+//repipeline: this does nothing, but maybe it should do something? we don't have the right variables though....
+void nsHttpPipeline::TopLevelOuterContentWindowIdChanged(uint64_t windowId) {
+  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+
+  /*mCurrentForegroundTabOuterContentWindowId = windowId;
+
+  for (auto iter = mStreamTransactionHash.Iter(); !iter.Done(); iter.Next()) {
+    iter.Data()->TopLevelOuterContentWindowIdChanged(windowId);
+  }*/
+}
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/nsHttpPipeline.h b/netwerk/protocol/http/nsHttpPipeline.h
new file mode 100644
index 0000000..94c5dfd
--- /dev/null
+++ b/netwerk/protocol/http/nsHttpPipeline.h
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsHttpPipeline_h__
+#define nsHttpPipeline_h__
+
+#include "nsAHttpConnection.h"
+#include "nsAHttpTransaction.h"
+#include "nsTArray.h"
+#include "nsCOMPtr.h"
+
+class nsIInputStream;
+class nsIOutputStream;
+
+namespace mozilla { namespace net {
+
+class nsHttpPipeline final : public nsAHttpConnection
+                           , public nsAHttpTransaction
+                           , public nsAHttpSegmentReader
+{
+public:
+    NS_DECL_THREADSAFE_ISUPPORTS
+    NS_DECL_NSAHTTPCONNECTION(mConnection)
+    NS_DECL_NSAHTTPTRANSACTION
+    NS_DECL_NSAHTTPSEGMENTREADER
+
+    nsHttpPipeline();
+
+  bool ResponseTimeoutEnabled() const override final {
+    return true;
+  }
+
+  uint32_t RequestDepth() { return mRequestQ.Length(); }
+
+private:
+    virtual ~nsHttpPipeline();
+
+    nsresult FillSendBuf();
+
+    static nsresult ReadFromPipe(nsIInputStream *, void *, const char *,
+                                 uint32_t, uint32_t, uint32_t *);
+
+    void ShuffleTransOrder(uint32_t);
+
+    // convenience functions
+    nsAHttpTransaction *Request(int32_t i)
+    {
+        if (mRequestQ.Length() == 0)
+            return nullptr;
+
+        return mRequestQ[i];
+    }
+    nsAHttpTransaction *Response(int32_t i)
+    {
+        if (mResponseQ.Length() == 0)
+            return nullptr;
+
+        return mResponseQ[i];
+    }
+
+    // overload of nsAHttpTransaction::QueryPipeline()
+    nsHttpPipeline *QueryPipeline() override;
+
+    RefPtr<nsAHttpConnection>   mConnection;
+    nsTArray<RefPtr<nsAHttpTransaction> > mRequestQ;
+    nsTArray<RefPtr<nsAHttpTransaction> > mResponseQ;
+    nsresult                      mStatus;
+
+    // these flags indicate whether or not the first request or response
+    // is partial.  a partial request means that Request(0) has been
+    // partially written out to the socket.  a partial response means
+    // that Response(0) has been partially read in from the socket.
+    bool mRequestIsPartial;
+    bool mResponseIsPartial;
+
+    // indicates whether or not the pipeline has been explicitly closed.
+    bool mClosed;
+
+    // indicates whether or not a true pipeline (more than 1 request without
+    // a synchronous response) has been formed.
+    bool mUtilizedPipeline;
+
+    // used when calling ReadSegments/WriteSegments on a transaction.
+    nsAHttpSegmentReader *mReader;
+
+    // send buffer
+    nsCOMPtr<nsIInputStream>  mSendBufIn;
+    nsCOMPtr<nsIOutputStream> mSendBufOut;
+
+    // the push back buffer.  not exceeding nsIOService::gDefaultSegmentSize bytes.
+    char     *mPushBackBuf;
+    uint32_t  mPushBackLen;
+    uint32_t  mPushBackMax;
+
+    // The number of transactions completed on this pipeline.
+    uint32_t  mHttp1xTransactionCount;
+
+    // For support of OnTransportStatus()
+    int64_t  mReceivingFromProgress;
+    int64_t  mSendingToProgress;
+    bool     mSuppressSendEvents;
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // nsHttpPipeline_h__
diff --git a/netwerk/protocol/http/nsHttpTransaction.cpp b/netwerk/protocol/http/nsHttpTransaction.cpp
index c0897d8..9346afe 100644
--- a/netwerk/protocol/http/nsHttpTransaction.cpp
+++ b/netwerk/protocol/http/nsHttpTransaction.cpp
@@ -44,6 +44,10 @@
 #include "sslerr.h"
 #include <algorithm>
 
+//blast:
+#include "sys/time.h"
+#include "mozilla/Logging.h"
+
 //-----------------------------------------------------------------------------
 
 static NS_DEFINE_CID(kMultiplexInputStream, NS_MULTIPLEXINPUTSTREAM_CID);
@@ -98,6 +102,8 @@ nsHttpTransaction::nsHttpTransaction()
       mPriority(0),
       mRestartCount(0),
       mCaps(0),
+      mClassification(CLASS_GENERAL),
+      mPipelinePosition(0),
       mHttpVersion(NS_HTTP_VERSION_UNKNOWN),
       mHttpResponseCode(0),
       mCurrentHttpResponseHeaderSize(0),
@@ -226,6 +232,16 @@ nsHttpTransaction::~nsHttpTransaction() {
   ReleaseBlockingTransaction();
 }
 
+nsHttpTransaction::Classifier nsHttpTransaction::Classify()
+{
+    //repipeline: always CLASS_GENERAL, unless pipelinng isn't allowed.
+
+    if (!(mCaps & NS_HTTP_ALLOW_PIPELINING))
+        return (mClassification = CLASS_SOLO);
+    mClassification = CLASS_GENERAL;
+    return mClassification;
+}
+
 nsresult nsHttpTransaction::Init(
     uint32_t caps, nsHttpConnectionInfo *cinfo, nsHttpRequestHead *requestHead,
     nsIInputStream *requestBody, uint64_t requestContentLength,
@@ -266,6 +282,16 @@ nsresult nsHttpTransaction::Init(
   }
   mChannel = do_QueryInterface(eventsink);
 
+
+    nsAutoCString tbrlog_method;
+    requestHead->Method(tbrlog_method);
+    nsAutoCString tbrlog_URI;
+    requestHead->RequestURI(tbrlog_URI);
+    nsAutoCString tbrlog_origin;
+    requestHead->Origin(tbrlog_origin);
+
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpTransaction::Init\tptr=%p\tmethodname=%s\tURI=%s\torigin=%s\tchannel=%p\n", this, tbrlog_method.get(), tbrlog_URI.get(), tbrlog_origin.get(), this->HttpChannel()));
+
   nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
       do_QueryInterface(eventsink);
   if (httpChannelInternal) {
@@ -404,6 +430,12 @@ nsresult nsHttpTransaction::Init(
     }
   }
 
+  uint64_t size_u64;
+  rv = mRequestStream->Available(&size_u64);
+  if (NS_FAILED(rv)) {
+      return rv;
+  }
+
   // make sure request content-length fits within js MAX_SAFE_INTEGER
   mRequestSize = InScriptableRange(requestContentLength)
                      ? static_cast<int64_t>(requestContentLength)
@@ -421,6 +453,8 @@ nsresult nsHttpTransaction::Init(
   MOZ_DIAGNOSTIC_ASSERT(*vtable != 0);
 #endif  // WIN32
 
+  Classify(); //repipeline
+
   nsCOMPtr<nsIAsyncInputStream> tmp(mPipeIn);
   tmp.forget(responseBody);
   return NS_OK;
@@ -675,6 +709,15 @@ void nsHttpTransaction::SetDNSWasRefreshed() {
   mCapsToClear |= NS_HTTP_REFRESH_DNS;
 }
 
+uint64_t
+nsHttpTransaction::Available()
+{
+    uint64_t size;
+    if (NS_FAILED(mRequestStream->Available(&size)))
+        size = 0;
+    return size;
+}
+
 nsresult nsHttpTransaction::ReadRequestSegment(nsIInputStream *stream,
                                                void *closure, const char *buf,
                                                uint32_t offset, uint32_t count,
@@ -686,6 +729,14 @@ nsresult nsHttpTransaction::ReadRequestSegment(nsIInputStream *stream,
   nsresult rv = trans->mReader->OnReadSegment(buf, count, countRead);
   if (NS_FAILED(rv)) return rv;
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpTransaction::ReadRequestSegment\tptr=%p\toffset=%zu\tcount=%zu\tcountRead=%zu\n", trans, offset, count, *countRead));  
+  char* buflimit = (char*)malloc(*countRead+2);
+  for (int i = 0; i < *countRead; i++) {
+        buflimit[i] = buf[i];
+  }
+  buflimit[*countRead] = '\0';
+  MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpTransaction::ReadRequestSegment\tdata=%s", buflimit));
+
   LOG(("nsHttpTransaction::ReadRequestSegment %p read=%u", trans, *countRead));
 
   trans->mSentData = true;
@@ -783,6 +834,14 @@ nsresult nsHttpTransaction::WritePipeSegment(nsIOutputStream *stream,
   rv = trans->mWriter->OnWriteSegment(buf, count, countWritten);
   if (NS_FAILED(rv)) return rv;  // caller didn't want to write anything
 
+  MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpTransaction::WritePipeSegment\tptr=%p\toffset=%zu\tcount=%zu\tcountWritten=%zu\n", trans, offset, count, *countWritten));
+  char* buflimit = (char*)malloc(*countWritten+2);
+  for (int i = 0; i < *countWritten; i++) {
+        buflimit[i] = buf[i];
+  }
+  buflimit[*countWritten] = '\0';
+  MOZ_LOG(mylogger, LogLevel::Debug, ("f=nsHttpTransaction::WritePipeSegment\tdata=%s", buflimit));
+
   LOG(("nsHttpTransaction::WritePipeSegment %p written=%u", trans,
        *countWritten));
 
@@ -1058,6 +1117,9 @@ void nsHttpTransaction::Close(nsresult reason) {
       // if restarting fails, then we must proceed to close the pipe,
       // which will notify the channel that the transaction failed.
 
+            gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+                mConnInfo, nsHttpConnectionMgr::RedCanceledPipeline, nullptr, 0); //repipeline
+
       if (NS_SUCCEEDED(Restart())) return;
     }
   }
@@ -1089,6 +1151,22 @@ void nsHttpTransaction::Close(nsresult reason) {
 
   bool relConn = true;
   if (NS_SUCCEEDED(reason)) {
+     //repipeline:
+     if (!mResponseIsComplete) {
+         // The response has not been delimited with a high-confidence
+         // algorithm like Content-Length or Chunked Encoding. We
+         // need to use a strong framing mechanism to pipeline.
+         gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+             mConnInfo, nsHttpConnectionMgr::BadInsufficientFraming,
+             nullptr, mClassification);
+     }
+     else if (mPipelinePosition) {
+         // report this success as feedback
+         gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+             mConnInfo, nsHttpConnectionMgr::GoodCompletedOK,
+             nullptr, mPipelinePosition);
+     }
+
     // the server has not sent the final \r\n terminating the header
     // section, and there may still be a header line unparsed.  let's make
     // sure we parse the remaining header line, and then hopefully, the
@@ -1153,6 +1231,12 @@ nsHttpConnectionInfo *nsHttpTransaction::ConnectionInfo() {
   return mConnInfo.get();
 }
 
+nsresult
+nsHttpTransaction::AddTransaction(nsAHttpTransaction *trans)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 bool  // NOTE BASE CLASS
 nsAHttpTransaction::ResponseTimeoutEnabled() const {
   return false;
@@ -1163,6 +1247,27 @@ nsAHttpTransaction::ResponseTimeout() {
   return gHttpHandler->ResponseTimeout();
 }
 
+uint32_t
+nsHttpTransaction::PipelineDepth()
+{
+    return IsDone() ? 0 : 1;
+}
+
+nsresult
+nsHttpTransaction::SetPipelinePosition(int32_t position)
+{
+    mPipelinePosition = position;
+    return NS_OK;
+}
+
+int32_t
+nsHttpTransaction::PipelinePosition()
+{
+    return mPipelinePosition;
+}
+
+
+
 bool nsHttpTransaction::ResponseTimeoutEnabled() const {
   return mResponseTimeoutEnabled;
 }
@@ -1321,6 +1426,9 @@ nsresult nsHttpTransaction::ParseLineSegment(char *segment, uint32_t len) {
       nsresult rv = ParseLine(mLineBuf);
       mLineBuf.Truncate();
       if (NS_FAILED(rv)) {
+                gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+                    mConnInfo, nsHttpConnectionMgr::RedCorruptedContent,
+                    nullptr, 0); //repipeline
         return rv;
       }
     }
@@ -1576,6 +1684,10 @@ nsresult nsHttpTransaction::HandleContentStart() {
       mNoContent = true;
     }
     mConnection->SetLastTransactionExpectedNoContent(mNoContent);
+        if (mInvalidResponseBytesRead)
+            gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+                mConnInfo, nsHttpConnectionMgr::BadInsufficientFraming,
+                nullptr, mClassification); //repipeline
 
     if (mNoContent) {
       mContentLength = 0;
@@ -1679,6 +1791,8 @@ nsresult nsHttpTransaction::HandleContent(char *buf, uint32_t count,
     }
 
     // the transaction is done with a complete response.
+
+    MOZ_LOG(mylogger, LogLevel::Info, ("f=nsHttpTransaction::HandleContent mResponseIsComplete\tptr=%p\tmContentLength=%" PRId64 "\tmTransferSize=%" PRId64 "\n", this, mContentLength, GetTransferSize()));
     mTransactionDone = true;
     mResponseIsComplete = true;
     ReleaseBlockingTransaction();
@@ -1790,6 +1904,23 @@ nsresult nsHttpTransaction::ProcessData(char *buf, uint32_t count,
   return NS_OK;
 }
 
+void
+nsHttpTransaction::CancelPipeline(uint32_t reason)
+{
+    // reason is casted through a uint to avoid compiler header deps
+    gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
+        mConnInfo,
+        static_cast<nsHttpConnectionMgr::PipelineFeedbackInfoType>(reason),
+        nullptr, mClassification);
+
+    mConnection->CancelPipeline(NS_ERROR_ABORT);
+
+    // Avoid pipelining this transaction on restart by classifying it as solo.
+    // This also prevents BadUnexpectedLarge from being reported more
+    // than one time per transaction.
+    mClassification = CLASS_SOLO;
+}
+
 void nsHttpTransaction::SetRequestContext(nsIRequestContext *aRequestContext) {
   LOG(("nsHttpTransaction %p SetRequestContext %p\n", this, aRequestContext));
   mRequestContext = aRequestContext;
diff --git a/netwerk/protocol/http/nsHttpTransaction.h b/netwerk/protocol/http/nsHttpTransaction.h
index bdf15d0..08f079f 100644
--- a/netwerk/protocol/http/nsHttpTransaction.h
+++ b/netwerk/protocol/http/nsHttpTransaction.h
@@ -126,6 +126,8 @@ class nsHttpTransaction final : public nsAHttpTransaction,
   void SetPriority(int32_t priority) { mPriority = priority; }
   int32_t Priority() { return mPriority; }
 
+  enum Classifier Classification() { return mClassification; }
+
   void PrintDiagnostics(nsCString &log);
 
   // Sets mPendingTime to the current time stamp or to a null time stamp (if now
@@ -134,6 +136,7 @@ class nsHttpTransaction final : public nsAHttpTransaction,
     mPendingTime = now ? TimeStamp::Now() : TimeStamp();
   }
   const TimeStamp GetPendingTime() { return mPendingTime; }
+  bool UsesPipelining() const { return mCaps & NS_HTTP_ALLOW_PIPELINING; }
 
   // overload of nsAHttpTransaction::RequestContext()
   nsIRequestContext *RequestContext() override { return mRequestContext.get(); }
@@ -215,6 +218,9 @@ class nsHttpTransaction final : public nsAHttpTransaction,
   void DeleteSelfOnConsumerThread();
   void ReleaseBlockingTransaction();
 
+  Classifier Classify();
+  void       CancelPipeline(uint32_t reason);
+
   static MOZ_MUST_USE nsresult ReadRequestSegment(nsIInputStream *, void *,
                                                   const char *, uint32_t,
                                                   uint32_t, uint32_t *);
@@ -316,6 +322,8 @@ class nsHttpTransaction final : public nsAHttpTransaction,
   uint16_t
       mRestartCount;  // the number of times this transaction has been restarted
   uint32_t mCaps;
+  enum Classifier                 mClassification;
+  int32_t                         mPipelinePosition;
 
   nsHttpVersion mHttpVersion;
   uint16_t mHttpResponseCode;
